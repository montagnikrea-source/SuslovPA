#!/usr/bin/env node\n// memtest-noninput-mobile.js\n// Usage:\n//   node memtest-noninput-mobile.js --url="https://montagnikrea-source.github.io/SuslovPA/noninput-mobile.html" --iterations=30 --delay=1000 --messages=20\n//\n// The script launches Chromium and Firefox via Playwright, simulates interactions specific to this page,\n// samples process RSS via pidusage and (when available) performance.memory.usedJSHeapSize,\n// and prints a simple analysis.\n\nconst { chromium, firefox } = require('playwright');\nconst pidusage = require('pidusage');\nconst yargs = require('yargs/yargs');\nconst { hideBin } = require('yargs/helpers');\n\nconst argv = yargs(hideBin(process.argv))\n  .option('url', { type: 'string', demandOption: true })\n  .option('iterations', { type: 'number', default: 30 })\n  .option('delay', { type: 'number', default: 1000 })\n  .option('headless', { type: 'boolean', default: true })\n  .option('operaExecutable', { type: 'string' })\n  .option('messages', { type: 'number', default: 10, describe: 'Number of messages to send each iteration' })\n  .option('clearChat', { type: 'boolean', default: false, describe: 'Clear chat messages between iterations (set false to stress accumulation)' })\n  .argv;\n\nasync function samplePidMemory(pid) {\n  try {\n    const stat = await pidusage(pid);\n    return { rssBytes: stat.memory, cpu: stat.cpu };\n  } catch (e) {\n    return { rssBytes: null, cpu: null, error: String(e) };\n  }\n}\n\nasync function interactPageForIteration(page) {\n  // Wait page ready\n  await page.waitForLoadState('load');\n\n  // Small interactions matching page behavior:\n  // 1. Toggle theme\n  try {\n    await page.click('#themeToggleMobile', { timeout: 2000 });\n    await page.waitForTimeout(100);\n    await page.click('#themeToggleMobile', { timeout: 2000 });\n  } catch (e) {}\n\n  // 2. Open chat\n  try {\n    await page.click('#chatFab', { timeout: 2000 });\n    await page.waitForTimeout(200);\n  } catch (e) {}\n\n  // 3. Send multiple messages to grow DOM (simulate user)\n  for (let i = 0; i < argv.messages; i++) {\n    try {\n      await page.fill('#messageInputMobile', `test-message-${Date.now()}-${i}`);\n      await page.click('#sendButtonMobile');\n      // give page time for simulated response (page code sends a response after 500ms)\n      await page.waitForTimeout(300);\n    } catch (e) {}\n  }\n\n  // 4. Scroll page up and down\n  await page.evaluate(() => {\n    window.scrollTo({ top: document.body.scrollHeight, behavior: 'auto' });\n  });\n  await page.waitForTimeout(100);\n  await page.evaluate(() => {\n    window.scrollTo({ top: 0, behavior: 'auto' });\n  });\n\n  // 5. Move sliders\n  try {\n    await page.evaluate(() => {\n      const sliders = ['#lrSliderMobile', '#l2SliderMobile', '#mixSliderMobile'];\n      sliders.forEach(s => {\n        const el = document.querySelector(s);\n        if (el) {\n          el.value = el.max;\n          el.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n      });\n    });\n  } catch (e) {}\n\n  // Optionally clear chat (if user asks)\n  if (argv.clearChat) {\n    await page.evaluate(() => {\n      const messagesDiv = document.getElementById('chatMessages');\n      if (messagesDiv) messagesDiv.innerHTML = '<div class="message system">Chat cleared</div>';\n    });\n  }\n}\n\nasync function runBrowserTest(browserName, launcher, launchOpts = {}) {\n  console.log(`\n=== Test: ${browserName} ===`);\n  const browser = await launcher.launch(launchOpts);\n  const browserPid = browser.process() ? browser.process().pid : null;\n  if (!browserPid) console.warn('Warning: cannot obtain browser PID - pid sampling disabled.');\n\n  const context = await browser.newContext({\n    viewport: { width: 390, height: 844 } // mobile-like viewport\n  });\n  const page = await context.newPage();\n\n  const samples = [];\n\n  for (let i = 0; i < argv.iterations; i++) {\n    const iter = i + 1;\n    try {\n      await page.goto(argv.url, { waitUntil: 'load', timeout: 60000 });\n    } catch (e) {\n      console.warn(`[${browserName}] navigate failed: ${e.message}`);\n    }\n\n    // run interaction that stresses chat + UI\n    await interactPageForIteration(page);\n\n    // wait a bit to let async callbacks execute\n    await page.waitForTimeout(argv.delay);\n\n    // sample process RSS\n    const pidSample = browserPid ? await samplePidMemory(browserPid) : { rssBytes: null };\n\n    // sample JS heap (Chromium only)\n    let jsHeap = null;\n    try {\n      jsHeap = await page.evaluate(() => {\n        try {\n          if (performance && performance.memory && performance.memory.usedJSHeapSize) {\n            return performance.memory.usedJSHeapSize;\n          }\n        } catch (e) {}\n        return null;\n      });\n    } catch (e) {\n      jsHeap = null;\n    }\n\n    samples.push({\n      iteration: iter,\n      timestamp: Date.now(),\n      rssBytes: pidSample.rssBytes,\n      cpu: pidSample.cpu,\n      jsHeapUsed: jsHeap\n    });\n\n    if (iter % Math.max(1, Math.floor(argv.iterations / 10)) === 0) {\n      console.log(`[${browserName}] progress ${iter}/${argv.iterations}`);\n    }\n  }\n\n  await browser.close();\n\n  // Analyze trend\n  function avg(arr, key) {\n    if (!arr.length) return null;\n    return arr.reduce((a, b) => a + (b[key] || 0), 0) / arr.length;\n  }\n\n  const validRss = samples.filter(s => typeof s.rssBytes === 'number');\n  const firstN = Math.min(5, validRss.length);\n  const lastN = Math.min(5, validRss.length);\n  const firstSlice = validRss.slice(0, firstN);\n  const lastSlice = validRss.slice(-lastN);\n  const avgFirst = avg(firstSlice, 'rssBytes');\n  const avgLast = avg(lastSlice, 'rssBytes');\n\n  console.log(`\n[${browserName}] samples: ${samples.length}`);\n  if (avgFirst && avgLast) {\n    const diff = avgLast - avgFirst;\n    const percent = (diff / avgFirst) * 100;\n    console.log(`[${browserName}] avg RSS first ${firstN}: ${(avgFirst / 1024 / 1024).toFixed(1)} MB`);\n    console.log(`[${browserName}] avg RSS last ${lastN}: ${(avgLast / 1024 / 1024).toFixed(1)} MB`);\n    console.log(`[${browserName}] change: ${(diff / 1024 / 1024).toFixed(1)} MB (${percent.toFixed(1)}%)`);\n    if (percent > 20 && diff > 20 * 1024 * 1024) {\n      console.warn(`[${browserName}] POSSIBLE MEMORY LEAK: RSS increased by ${percent.toFixed(1)}%`);\n    } else if (percent > 10) {\n      console.warn(`[${browserName}] Noticeable RSS growth (${percent.toFixed(1)}%) â€” investigate`);\n    } else {\n      console.log(`[${browserName}] No significant RSS growth detected`);\n    }\n  } else {\n    console.log(`[${browserName}] Not enough RSS samples`);\n  }\n\n  const validJs = samples.filter(s => typeof s.jsHeapUsed === 'number');\n  if (validJs.length) {\n    const avgFirstJs = avg(validJs.slice(0, firstN), 'jsHeapUsed');\n    const avgLastJs = avg(validJs.slice(-lastN), 'jsHeapUsed');\n    if (avgFirstJs && avgLastJs) {\n      const diffJs = avgLastJs - avgFirstJs;\n      const percentJs = (diffJs / avgFirstJs) * 100;\n      console.log(`[${browserName}] JS heap first ${firstN}: ${(avgFirstJs / 1024 / 1024).toFixed(2)} MB`);\n      console.log(`[${browserName}] JS heap last ${lastN}: ${(avgLastJs / 1024 / 1024).toFixed(2)} MB`);\n      console.log(`[${browserName}] JS heap change: ${(diffJs / 1024 / 1024).toFixed(2)} MB (${percentJs.toFixed(1)}%)`);\n      if (percentJs > 20 && diffJs > 10 * 1024 * 1024) {\n        console.warn(`[${browserName}] POSSIBLE JS HEAP LEAK`);\n      }\n    }\n  } else {\n    console.log(`[${browserName}] performance.memory samples not available (expected for Firefox)`);\n  }\n\n  return { browser: browserName, samples };\n}\n\n(async () => {\n  try {\n    console.log('Starting memory smoke tests for', argv.url);\n\n    const chromiumOpts = { headless: argv.headless };\n    if (argv.operaExecutable) chromiumOpts.executablePath = argv.operaExecutable;\n\n    const res1 = await runBrowserTest('Chromium', chromium, chromiumOpts);\n    const res2 = await runBrowserTest('Firefox', firefox, { headless: argv.headless });\n\n    const fs = require('fs');\n    fs.writeFileSync('memtest-noninput-mobile-results.json', JSON.stringify({ url: argv.url, timestamp: Date.now(), results: [res1, res2] }, null, 2));\n    console.log('Results saved to memtest-noninput-mobile-results.json');\n    process.exit(0);\n  } catch (err) {\n    console.error('Error:', err);\n    process.exit(2);\n  }\n})();\n