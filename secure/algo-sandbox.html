<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self'; connect-src 'none'; img-src 'none'; style-src 'none'; frame-ancestors 'none'; base-uri 'none'">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  <title>Algo Sandbox</title>
</head>
<body>
<script src="algorithm-core.js"></script>
<script>
(function(){
  'use strict';
  // Заморозка опасных примитивов
  try{ Function.prototype.constructor = undefined; }catch(_){ }
  try{ Object.freeze(Function); Object.freeze(eval); }catch(_){ }

  let running = false;
  let timer = null;
  let sampleRate = 60; // Гц
  let freezeLearning = false;
  let key = null; // AES-GCM key after handshake

  const state = {
    t0: performance.now(),
    f: 0,
    conf: 0.5,
    inertia: 0.2,
    J: 1.0,
    fs: 60,
    peak: 0.0,
  };

  // Реальный движок
  const Engine = window.buildEngine ? window.buildEngine() : null;

  async function telemetry(){
    const payload = { f:state.f, conf:state.conf, inertia:state.inertia, J:state.J, fs:state.fs, peak:state.peak };
    if(key){
      try{
        const p = await encrypt(payload);
        parent.postMessage({ type:'telemetry-enc', cipher:p.cipher, iv:p.iv }, '*');
        return;
      }catch(_){ }
    }
    parent.postMessage({ type:'telemetry', payload }, '*');
  }

  function step(){
    // Реальный ход
    try{
      // Добираем данные сэмплера
      const needCnt = Engine.scan.needCount();
      const avail=((Engine.s.widx - Engine.scan.r) & Engine.s.constructor.MASK);
      if(avail < needCnt){ for(let i=0;i<180;i++) Engine.s.sample(); telemetry(); return; }
      Engine.scan.processOnce();
      state.f = Engine.scan.out_f || 0;
      state.conf = Engine.scan.out_conf || 0;
      state.inertia = Engine.scan.out_inertia || 0;
      state.J = Engine.scan.tuner?.prevJ ?? 1.0;
      state.fs = Engine.scan.fs || sampleRate;
      state.peak = Engine.scan.out_peak || 1.0;
      telemetry();
    }catch(_){ /* не падаем */ }
    // Самопроверка целостности
    if((++_checks % 300)===0){
      if(_finger() !== baseline){
        try{ parent.postMessage({ type:'tamper' }, '*'); }catch(_){ }
        running=false; if(timer){clearTimeout(timer); timer=null;}
      }
    }
  }

  function loop(){
    if(!running) return;
    step();
    const dt = 1000/Math.max(10, sampleRate);
    timer = setTimeout(loop, dt);
  }

  function start(opts){
    if(running) return true;
    running = true;
    if (opts && typeof opts.sampleRate === 'number') sampleRate = opts.sampleRate;
    loop();
    return true;
  }
  function pause(){ running=false; if(timer){clearTimeout(timer); timer=null;} return true; }
  function stop(){ running=false; if(timer){clearTimeout(timer); timer=null;} state.f=0; return true; }
  function getMetrics(){ return { ...state, sampleRate, freeze: freezeLearning }; }

  // Самопроверка целостности (каждые ~300 шагов)
  let _checks=0; const _finger = () => (''+step).length ^ (''+loop).length ^ (''+encrypt).length;
  const baseline = _finger();

  window.addEventListener('message', (e)=>{
    const d = e.data || {};
    if(d.type==='handshake' && d.clientNonce){
      deriveKey(d.clientNonce, d.clientSalt).then(reply=>{
        parent.postMessage({ type:'handshake-ack', serverNonce: reply.serverNonce, serverSalt: reply.serverSalt }, '*');
      }).catch(()=>{});
      return;
    }
    if(d.type==='rpc'){
      let ok=true, result=null, error=null;
      try{
        if(d.method==='start') result = start(d.params||{});
        else if(d.method==='pause') result = pause();
        else if(d.method==='stop') result = stop();
        else if(d.method==='getMetrics') result = getMetrics();
        else { ok=false; error='unknown method'; }
      }catch(err){ ok=false; error=String(err&&err.message||err); }
      parent.postMessage({ type:'rpc:res', id:d.id, ok, result, error }, '*');
      return;
    }
    if(d.type==='control-enc' && d.cipher && d.iv){
      if(!key) return;
      decrypt(d.cipher, d.iv).then(params=>{
        if(typeof params.sampleRate === 'number') sampleRate = Math.max(10, Math.min(240, params.sampleRate));
        if(typeof params.freeze === 'boolean') freezeLearning = params.freeze;
      }).catch(()=>{});
      return;
    }
    if(d.type==='control' && d.params){
      if(typeof d.params.sampleRate === 'number') sampleRate = Math.max(10, Math.min(240, d.params.sampleRate));
      if(typeof d.params.freeze === 'boolean') freezeLearning = d.params.freeze;
    }
  });

  // Сообщаем, что готовы
  parent.postMessage({ type:'sandbox:ready' }, '*');

  async function deriveKey(clientNonceArr, clientSaltArr){
    // HKDF с солью и ротацией
    const client = new Uint8Array(clientNonceArr);
    const clientSalt = new Uint8Array(clientSaltArr||new Uint8Array(16));
    const serverNonce = crypto.getRandomValues(new Uint8Array(12));
    const serverSalt = crypto.getRandomValues(new Uint8Array(16));
    const saltConcat = new Uint8Array(clientSalt.length+serverSalt.length);
    saltConcat.set(clientSalt,0); saltConcat.set(serverSalt,clientSalt.length);
    const saltHash = await crypto.subtle.digest('SHA-256', saltConcat);
    const ikm = new Uint8Array(client.length+serverNonce.length);
    ikm.set(client,0); ikm.set(serverNonce,client.length);
    const base = await crypto.subtle.importKey('raw', ikm, 'HKDF', false, ['deriveKey']);
    key = await crypto.subtle.deriveKey({ name:'HKDF', hash:'SHA-256', salt: new Uint8Array(saltHash), info: new TextEncoder().encode('suslov-secure') }, base, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
    return { serverNonce: Array.from(serverNonce), serverSalt: Array.from(serverSalt) };
  }
  async function encrypt(obj){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder().encode(JSON.stringify(obj));
    const buf = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc);
    return { cipher: Array.from(new Uint8Array(buf)), iv: Array.from(iv) };
  }
  async function decrypt(cipherArr, ivArr){
    const iv = new Uint8Array(ivArr);
    const data = new Uint8Array(cipherArr);
    const buf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, data);
    const txt = new TextDecoder().decode(buf);
    return JSON.parse(txt);
  }
})();
</script>
</body>
</html>
