<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self'; connect-src 'none'; img-src 'none'; style-src 'none'; frame-ancestors 'none'; base-uri 'none'">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  <title>Algo Sandbox</title>
</head>
<body>
<script>
(function(){
  'use strict';
  // Заморозка опасных примитивов
  try{ Function.prototype.constructor = undefined; }catch(_){ }
  try{ Object.freeze(Function); Object.freeze(eval); }catch(_){ }

  let running = false;
  let timer = null;
  let sampleRate = 60; // Гц
  let freezeLearning = false;
  let key = null; // AES-GCM key after handshake

  const state = {
    t0: performance.now(),
    f: 0,
    conf: 0.5,
    inertia: 0.2,
    J: 1.0,
    fs: 60,
    peak: 0.0,
  };

  async function telemetry(){
    const payload = { f:state.f, conf:state.conf, inertia:state.inertia, J:state.J, fs:state.fs, peak:state.peak };
    if(key){
      try{
        const p = await encrypt(payload);
        parent.postMessage({ type:'telemetry-enc', cipher:p.cipher, iv:p.iv }, '*');
        return;
      }catch(_){ }
    }
    parent.postMessage({ type:'telemetry', payload }, '*');
  }

  function step(){
    // Упрощённая «модель»: плавное изменение частоты и метрик, чтобы UI жил
    const t = (performance.now() - state.t0)/1000;
    state.f = 10 + 5*Math.sin(t*0.5) + 2*Math.cos(t*0.2);
    state.conf = Math.max(0, Math.min(1, 0.6 + 0.3*Math.sin(t*0.3)));
    state.inertia = Math.max(0, Math.min(1, 0.3 + 0.5*Math.cos(t*0.25)));
    state.J = Math.max(0, 1.2 - 0.8*state.conf*state.inertia);
    state.fs = sampleRate;
    state.peak = Math.max(0.5, Math.min(2.0, 1.0 + 0.3*Math.sin(t*0.7)));
    telemetry();
  }

  function loop(){
    if(!running) return;
    step();
    const dt = 1000/Math.max(10, sampleRate);
    timer = setTimeout(loop, dt);
  }

  function start(opts){
    if(running) return true;
    running = true;
    if (opts && typeof opts.sampleRate === 'number') sampleRate = opts.sampleRate;
    loop();
    return true;
  }
  function pause(){ running=false; if(timer){clearTimeout(timer); timer=null;} return true; }
  function stop(){ running=false; if(timer){clearTimeout(timer); timer=null;} state.f=0; return true; }
  function getMetrics(){ return { ...state, sampleRate, freeze: freezeLearning }; }

  window.addEventListener('message', (e)=>{
    const d = e.data || {};
    if(d.type==='handshake' && d.clientNonce){
      deriveKey(d.clientNonce).then(serverNonce=>{
        parent.postMessage({ type:'handshake-ack', serverNonce: Array.from(serverNonce) }, '*');
      }).catch(()=>{});
      return;
    }
    if(d.type==='rpc'){
      let ok=true, result=null, error=null;
      try{
        if(d.method==='start') result = start(d.params||{});
        else if(d.method==='pause') result = pause();
        else if(d.method==='stop') result = stop();
        else if(d.method==='getMetrics') result = getMetrics();
        else { ok=false; error='unknown method'; }
      }catch(err){ ok=false; error=String(err&&err.message||err); }
      parent.postMessage({ type:'rpc:res', id:d.id, ok, result, error }, '*');
      return;
    }
    if(d.type==='control-enc' && d.cipher && d.iv){
      if(!key) return;
      decrypt(d.cipher, d.iv).then(params=>{
        if(typeof params.sampleRate === 'number') sampleRate = Math.max(10, Math.min(240, params.sampleRate));
        if(typeof params.freeze === 'boolean') freezeLearning = params.freeze;
      }).catch(()=>{});
      return;
    }
    if(d.type==='control' && d.params){
      if(typeof d.params.sampleRate === 'number') sampleRate = Math.max(10, Math.min(240, d.params.sampleRate));
      if(typeof d.params.freeze === 'boolean') freezeLearning = d.params.freeze;
    }
  });

  // Сообщаем, что готовы
  parent.postMessage({ type:'sandbox:ready' }, '*');

  async function deriveKey(clientNonceArr){
    const client = new Uint8Array(clientNonceArr);
    const server = crypto.getRandomValues(new Uint8Array(12));
    const concat = new Uint8Array(client.length+server.length);
    concat.set(client,0); concat.set(server,client.length);
    const hash = await crypto.subtle.digest('SHA-256', concat);
    const raw = new Uint8Array(hash);
    key = await crypto.subtle.importKey('raw', raw, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
    return server;
  }
  async function encrypt(obj){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder().encode(JSON.stringify(obj));
    const buf = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc);
    return { cipher: Array.from(new Uint8Array(buf)), iv: Array.from(iv) };
  }
  async function decrypt(cipherArr, ivArr){
    const iv = new Uint8Array(ivArr);
    const data = new Uint8Array(cipherArr);
    const buf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, data);
    const txt = new TextDecoder().decode(buf);
    return JSON.parse(txt);
  }
})();
</script>
</body>
</html>
