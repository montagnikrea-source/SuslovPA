class NeuralNetwork { constructor(initialNeurons = 4, maxResourceUsage = 80) { this.HMin = 4; this.H = Math.max(this.HMin, Math.floor(initialNeurons)); this.maxResourceUsage = maxResourceUsage; this.neurons = this.createNeurons(this.H); this.weights = this.initializeWeights(this.H); this.metrics = { resourceUsage: 0, quality: 100, frozen: false }; } createNeurons(count) { count = Math.max(this.HMin, Math.floor(count)); return Array.from({ length: count }, () => ({ output: 0 })); } initializeWeights(count) { return Array.from({ length: count }, () => { let w = Math.random(); return (isFinite(w) && w > 0) ? w : 0.01; }); } processInput(input = []) { if (!Array.isArray(input) || input.some(val => !isFinite(val))) return; let sum = input.reduce((a, b) => a + b, 0); sum = isFinite(sum) ? sum : 0; let avg = input.length ? sum / input.length : 0; avg = isFinite(avg) ? avg : 0; for (let i = 0; i < this.H; i++) { let net = (avg * this.weights[i]) || 0; this.neurons[i].output = this.activation(net); } } activation(x) { if (!isFinite(x)) return 0; return Math.log(Math.abs(x) + 1); } calcResourceUsage() { let usage = (this.H / 1000) * 100; usage = Math.min(100, Math.max(0, usage)); return isFinite(usage) ? usage : 0; } autoScaleArchitecture() { this.metrics.resourceUsage = this.calcResourceUsage(); if (this.metrics.resourceUsage > this.maxResourceUsage) { this.H = Math.max(this.HMin, Math.floor(this.H * 0.9)); } else if (this.metrics.quality > 90 && this.metrics.resourceUsage < (this.maxResourceUsage * 0.5)) { this.H = this.H + 1; } this.neurons = this.createNeurons(this.H); this.weights = this.initializeWeights(this.H); } updateQuality(q) { this.metrics.quality = isFinite(q) ? Math.max(0, Math.min(100, q)) : 0; } freezeIfCritical() { if (this.metrics.resourceUsage > 95) this.metrics.frozen = true; else this.metrics.frozen = false; } run(input) { this.processInput(input); this.autoScaleArchitecture(); this.freezeIfCritical(); } }