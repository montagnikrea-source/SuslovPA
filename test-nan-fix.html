<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test NaN Fix and Architecture Scaling</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1e1e1e; color: #d4d4d4; }
        .test { border: 1px solid #666; padding: 10px; margin: 10px 0; }
        .pass { background: #1a4d1a; color: #4eff4e; }
        .fail { background: #4d1a1a; color: #ff6b6b; }
        h1 { color: #4ab8ff; }
        h2 { color: #f0ad4e; }
        pre { background: #2d2d2d; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>🧪 Test Suite: NaN Fix & Unlimited Architecture</h1>
    
    <div id="tests"></div>
    
    <script>
        // Mock NeuroHomeo for testing
        class TestNeuroHomeo {
            constructor() {
                this.HMin = 4;
                this.HStep = 2;
                this.maxDynamicH = 64;
                this.H = 4;
                this.emaAbsPhi = undefined; // Simulate uninitialized
                this.emaAbsDf = NaN;
                this.emaAbsU = NaN;
                this.emaOneMinConf = 1;
                this.emaOneMinIner = 1;
                this.emaResourceUsage = undefined;
                this.qualityHistory = [];
            }
            
            // Simulated cost function WITH NaN protection
            cost(phi, dphi, u, confidence, inertia) {
                // ===== ЗАЩИТА ОТ NaN =====
                if(!isFinite(this.emaAbsPhi)) this.emaAbsPhi = 0;
                if(!isFinite(this.emaAbsDf)) this.emaAbsDf = 0;
                if(!isFinite(this.emaAbsU)) this.emaAbsU = 0;
                if(!isFinite(this.emaOneMinConf)) this.emaOneMinConf = 1;
                if(!isFinite(this.emaOneMinIner)) this.emaOneMinIner = 1;
                if(!isFinite(this.emaResourceUsage)) this.emaResourceUsage = 0;
                
                // EMA updates
                const alpha = 0.2;
                this.emaAbsPhi = alpha * Math.abs(phi) + (1 - alpha) * this.emaAbsPhi;
                this.emaAbsDf = alpha * Math.abs(dphi) + (1 - alpha) * this.emaAbsDf;
                this.emaAbsU = alpha * Math.abs(u) + (1 - alpha) * this.emaAbsU;
                
                // Cost calculation
                const baseCost = this.emaAbsPhi + this.emaAbsDf + this.emaAbsU;
                const resourcePenalty = 0.1 * this.emaResourceUsage;
                const result = baseCost + resourcePenalty;
                
                return isFinite(result) ? result : 0;
            }
            
            autoScaleArchitecture(quality, resourceUsage) {
                this.qualityHistory.push(quality);
                if(this.qualityHistory.length > 20) this.qualityHistory.shift();
                
                const avgQuality = this.qualityHistory.reduce((a,b)=>a+b,0) / this.qualityHistory.length;
                
                // NO HARD UPPER LIMIT - UNLIMITED GROWTH
                if(resourceUsage > 0.80) {
                    if(this.H > this.HMin) this.H -= this.HStep;
                } else if(avgQuality < 0.30 && resourceUsage < 0.50) {
                    this.H += this.HStep;  // ← No this.HMax limit!
                } else if(avgQuality > 0.70 && resourceUsage < 0.40) {
                    this.H += this.HStep;  // ← No this.HMax limit!
                } else if(resourceUsage > 0.50 && avgQuality > 0.5 && this.H > this.HMin) {
                    this.H -= this.HStep;
                }
            }
        }
        
        // Test Suite
        const tests = [];
        
        function test(name, fn) {
            tests.push({ name, fn });
        }
        
        function addTest(name, result, expected) {
            test(name, () => {
                const pass = result === expected;
                return {
                    pass,
                    message: pass 
                        ? `✅ ${name}`
                        : `❌ ${name}: expected ${expected}, got ${result}`
                };
            });
        }
        
        // ===== TEST SUITE =====
        
        test("NaN Protection: Uninitialized EMA becomes 0", () => {
            const nn = new TestNeuroHomeo();
            const cost = nn.cost(0.1, 0.05, 0.02, 0.8, 0.7);
            return {
                pass: isFinite(cost),
                message: cost === 0 ? `✅ Cost initialized to 0, then updated` : `✅ Cost is finite: ${cost}`
            };
        });
        
        test("NaN Protection: NaN input doesn't produce NaN output", () => {
            const nn = new TestNeuroHomeo();
            nn.emaAbsPhi = NaN;
            nn.emaAbsDf = NaN;
            nn.emaAbsU = NaN;
            const cost = nn.cost(0.1, 0.05, 0.02, 0.8, 0.7);
            return {
                pass: isFinite(cost) && cost >= 0,
                message: isFinite(cost) 
                    ? `✅ NaN inputs converted to 0, result: ${cost.toFixed(6)}`
                    : `❌ Result is still NaN: ${cost}`
            };
        });
        
        test("Quality Calculation: 1.0 - finite cost doesn't produce NaN", () => {
            const nn = new TestNeuroHomeo();
            const cost = nn.cost(0.1, 0.05, 0.02, 0.8, 0.7);
            const quality = 1.0 - cost;
            return {
                pass: isFinite(quality) && quality >= 0 && quality <= 1,
                message: isFinite(quality)
                    ? `✅ Quality: ${quality.toFixed(4)} (${(quality*100).toFixed(0)}%)`
                    : `❌ Quality is NaN`
            };
        });
        
        test("Architecture: No hard upper limit allows growth past 16", () => {
            const nn = new TestNeuroHomeo();
            nn.H = 16; // Old HMax
            
            // Simulate good quality + low resources
            for(let i = 0; i < 5; i++) {
                nn.qualityHistory.push(0.8); // High quality
            }
            
            nn.autoScaleArchitecture(0.8, 0.3); // Good quality, low resources
            
            return {
                pass: nn.H === 18,
                message: nn.H === 18
                    ? `✅ Scaled from 16 to 18 (no hard limit)`
                    : `❌ Did not scale: H = ${nn.H}`
            };
        });
        
        test("Architecture: Further growth continues without limit", () => {
            const nn = new TestNeuroHomeo();
            nn.H = 18;
            
            for(let i = 0; i < 5; i++) {
                nn.qualityHistory.push(0.8);
            }
            
            nn.autoScaleArchitecture(0.8, 0.3);
            
            return {
                pass: nn.H === 20,
                message: nn.H === 20
                    ? `✅ Scaled from 18 to 20 (unlimited growth)`
                    : `❌ Did not scale: H = ${nn.H}`
            };
        });
        
        test("Architecture: Resource pressure limits scaling", () => {
            const nn = new TestNeuroHomeo();
            nn.H = 4;
            nn.emaResourceUsage = 0.85; // High resources
            
            nn.autoScaleArchitecture(0.5, 0.85);
            
            return {
                pass: nn.H === 2 || nn.H === 4, // Either shrinks to min or stays
                message: nn.H <= 4
                    ? `✅ High resources prevented scaling (H=${nn.H})`
                    : `❌ Scaled despite high resources: H=${nn.H}`
            };
        });
        
        test("Architecture: Minimum floor HMin=4 prevents over-shrinking", () => {
            const nn = new TestNeuroHomeo();
            nn.H = 4; // Already at minimum
            nn.emaResourceUsage = 0.9;
            
            nn.autoScaleArchitecture(0.2, 0.9);
            
            return {
                pass: nn.H === 4,
                message: nn.H === 4
                    ? `✅ Minimum floor enforced (H=${nn.H})`
                    : `❌ Went below minimum: H=${nn.H}`
            };
        });
        
        test("Display: Quality percentage renders without NaN", () => {
            const nn = new TestNeuroHomeo();
            const cost = nn.cost(0.1, 0.05, 0.02, 0.8, 0.7);
            const qualityVal = Math.max(0, 1.0 - cost);
            const qualityPercent = isFinite(qualityVal) 
                ? (qualityVal*100).toFixed(0) + '%'
                : '?';
            
            return {
                pass: qualityPercent !== 'NaN%' && qualityPercent.includes('%'),
                message: `✅ Quality displays as "${qualityPercent}"`
            };
        });
        
        test("Display: H value renders safely", () => {
            const nn = new TestNeuroHomeo();
            const hVal = isFinite(nn.H) ? nn.H : 4;
            
            return {
                pass: hVal === 4 && isFinite(hVal),
                message: `✅ H displays as ${hVal}`
            };
        });
        
        // Run all tests
        const results = tests.map(t => t.fn());
        
        // Display results
        const testsDiv = document.getElementById('tests');
        results.forEach((r, i) => {
            const div = document.createElement('div');
            div.className = `test ${r.pass ? 'pass' : 'fail'}`;
            div.textContent = r.message;
            testsDiv.appendChild(div);
        });
        
        // Summary
        const passed = results.filter(r => r.pass).length;
        const total = results.length;
        const summary = document.createElement('div');
        summary.className = passed === total ? 'pass' : 'fail';
        summary.style.marginTop = '20px';
        summary.style.fontSize = '16px';
        summary.style.fontWeight = 'bold';
        summary.textContent = `TOTAL: ${passed}/${total} tests passed`;
        testsDiv.appendChild(summary);
        
        console.log(`✅ Test Suite Complete: ${passed}/${total} passed`);
    </script>
</body>
</html>
