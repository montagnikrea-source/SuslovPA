<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Frequency Scanner — Homeostatic Zero-Target (CPU-only)</title>
  <style>
    :root { --bg:#f3f5f7; --panel:#fff; --muted:#556; --bar:#e8ebef; }
    html,body{margin:0;background:var(--bg);font:14px/1.45 system-ui,Segoe UI,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:24px;background:var(--panel);border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07)}
    h1{margin:0 0 10px}
    #loading{margin:6px 0 12px}
    #loading .bg{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    #loading .fill{height:100%;width:0%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);transition:width .25s ease-out}
    #statusText{color:var(--muted);margin-top:6px}
    .row{margin-top:12px}
    .lbl{margin:10px 0 6px}
    .bar{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    .f{height:100%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);width:0%}
    .i{height:100%;background:linear-gradient(90deg,#18b56c 60%,#9ef0c5);width:0%}
    .c{height:100%;background:linear-gradient(90deg,#ff9800 60%,#ffd699);width:0%}
    #info{margin-top:14px;font-family:ui-monospace,Consolas,Menlo,monospace;white-space:pre-wrap;color:#222}
    .hint{color:#444;margin-top:8px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Frequency Scanner — Homeostatic Zero-Target (CPU-only)</h1>

  <div id="loading">
    <div class="bg"><div id="loadingBar" class="fill"></div></div>
    <div id="statusText">Плавное накопление…</div>
  </div>

  <div class="row">
    <div class="lbl">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
    <div class="bar"><div id="freqBar" class="f"></div></div>

    <div class="lbl">Стабильность (%): <span id="inertiaValue">0</span></div>
    <div class="bar"><div id="inertiaBar" class="i"></div></div>

    <div class="lbl">Уверенность: <span id="confValue">0</span></div>
    <div class="bar"><div id="confBar" class="c"></div></div>
  </div>

  <div id="info"></div>
  <div class="hint">Цель автоматики — J→0: |φ|, |Δf|, Var(Δf), |u|, (1−conf), (1−inertia) → 0. Полностью автономно.</div>
</div>

<script>
/* ====================== CPU-сэмплер ====================== */
class CpuJitterSampler {
  static RB_SIZE=16384; static MASK=CpuJitterSampler.RB_SIZE-1;
  constructor(){
    this.rb=new Float64Array(CpuJitterSampler.RB_SIZE);
    this.ts=new Float64Array(CpuJitterSampler.RB_SIZE);
    this.widx=0;
    this.target_ms=2.0; this.iters=800; this.iters_min=120; this.iters_max=150000;
    this.alpha=0.008; this.ema=0; this.rms=0;
    this.dynamic_n=64; this.actual_fs=500;
    this.sample_count=0; this.last_widx=0; this.last_check=performance.now(); this.stall_count=0;
    this._medBuf=new Float64Array(9); this._mi=0; this._mlen=0;
  }
  _kernel(n){let x=1.0001; for(let i=0;i<n;i++){x*=1.00000001; x/=1.000000009;}}
  _median9(x){const n=this._mlen<9?++this._mlen:9; this._medBuf[this._mi]=x; this._mi=(this._mi+1)%9; const t=Array.from(this._medBuf.slice(0,n)).sort((a,b)=>a-b); return t[(n>>1)];}
  sample(){
    const t0=performance.now(); this._kernel(this.iters);
    let dt=performance.now()-t0; dt=this._median9(dt);
    if(!this.ema) this.ema=dt; this.ema=(1-this.alpha)*this.ema+this.alpha*dt;
    const jitter=dt-this.ema; const idx=(this.widx++)&CpuJitterSampler.MASK;
    this.rb[idx]=jitter; this.ts[idx]=t0; this.sample_count++;
    this.rms=(1-this.alpha)*this.rms + this.alpha*jitter*jitter;
    if((this.sample_count & 0x7F)===0){
      const ratio=this.ema/Math.max(0.25,this.target_ms);
      const k=Math.max(0.65,Math.min(1.5,1/ratio));
      this.iters=Math.max(this.iters_min, Math.min(this.iters_max, Math.round(this.iters*k)));
      this.actual_fs=1000/Math.max(0.25,this.ema);
      this.dynamic_n=Math.max(48, Math.min(512, Math.ceil(0.30*this.actual_fs))); // ~0.3s окна
    }
  }
  checkStall(){
    const now=performance.now();
    if(now-this.last_check>1000 && this.widx===this.last_widx){
      this.stall_count++;
      if(this.stall_count>2){
        this.iters=Math.max(this.iters_min,(this.iters/1.8)|0);
        this.target_ms=Math.min(6.0,this.target_ms*1.12);
        this.stall_count=0;
      }
      return true;
    }
    this.last_check=now; this.last_widx=this.widx; this.stall_count=0; return false;
  }
}

/* ======================= Goertzel ======================= */
class Goertzel{
  init(n,fs,f){this.N=n;const k=Math.floor(0.5+n*f/fs);const w=2*Math.PI*k/n;
    this.cw=Math.cos(w); this.sw=Math.sin(w); this.s1=0; this.s2=0;}
  push(x){const s=x+2*this.cw*this.s1 - this.s2; this.s2=this.s1; this.s1=s;}
  result(){const re=this.s1 - this.s2*this.cw, im=this.s2*this.sw;
    const mag=Math.hypot(re,im)/(this.N>1?(this.N/2):1); const ph=Math.atan2(im,re);
    return {mag, ph};
  }
}

/* ===================== OutputBlender ==================== */
class OutputBlender{
  constructor(){this.ready=false;this.ramp=0;this.last={f:0,conf:0,inertia:0,state:'SEARCHING'};}
  blend(cur,step=0.18){ if(!this.ready){this.last={...cur};this.ready=true;this.ramp=Math.min(1,this.ramp+step);return cur;}
    const a=Math.min(1,this.ramp+step);this.ramp=a; const mix=(p,q)=>p*(1-a)+q*a;
    const out={f:mix(this.last.f,cur.f),conf:mix(this.last.conf,cur.conf),inertia:mix(this.last.inertia,cur.inertia),state:cur.state};
    this.last=out; return out;
  }
  hold(step=0.08){ this.ramp=Math.min(1,this.ramp+step); return this.last; }
}

/* ======================== Kalman ======================== */
class Kalman{
  constructor(x0,v0,qpos,qvel){ this.qp=qpos; this.qv=qvel; this.reset(x0,v0); }
  reset(x,v){ this.x=x; this.v=v; this.p00=1; this.p01=0; this.p10=0; this.p11=1; }
  predict(dt){
    this.x += this.v*dt;
    this.p00 += dt*(this.p10+this.p01) + dt*dt*this.p11;
    this.p01 += dt*this.p11; this.p10 += dt*this.p11;
    this.p00 += this.qp; this.p11 += this.qv;
  }
  update(z,r){
    const y=z-this.x, s=this.p00+r; if(Math.abs(s)<1e-9) return;
    const k0=this.p00/s, k1=this.p10/s;
    this.x += k0*y; this.v += k1*y;
    const p00=this.p00, p01=this.p01;
    this.p00 -= k0*p00; this.p01 -= k0*p01;
    this.p10 -= k1*p00; this.p11 -= k1*p01;
  }
}

/* =================== Homeostatic tuner (J→0) =================== */
/* Совокупная «стоимость»:
   J = wφ*E|φ| + wΔf*E|Δf| + wVar*sqrt(E[Δf²]) + wU*E|u| + wC*(1-conf) + wI*(1-inertia)
   Цель: J → 0. PI-регулятор подстраивает агрессивность aggr и, через неё, полосу, демпфирование и slew.
*/
class HomeoTuner {
  constructor(){
    this.aggr = 1.0;                   // 0.5..2.0
    this.I = 0;                        // интеграл ошибки по J
    this.Imax = 3.0;

    // EMA характеристик
    this.emaAbsPhi = 0;
    this.emaAbsDf  = 0;
    this.emaVarDf  = 0;
    this.emaAbsU   = 0;
    this.emaOneMinConf = 1;
    this.emaOneMinIner = 1;

    this.a = 0.12;                     // скорость EMA метрик

    // веса (масштабированы так, чтобы вклад был сопоставим)
    this.w_phi = 1.0;
    this.w_df  = 0.8;
    this.w_var = 0.9;
    this.w_u   = 0.7;
    this.w_c   = 0.9;
    this.w_i   = 0.7;

    // PI по J: aggr += Kp*(-J) + Ki*∫(-J)
    this.Kp = 0.35;
    this.Ki = 0.10;
  }

  updateMetrics({phi, df, u, conf, inertia}){
    const a=this.a;
    this.emaAbsPhi     = (1-a)*this.emaAbsPhi     + a*Math.abs(phi);
    this.emaAbsDf      = (1-a)*this.emaAbsDf      + a*Math.abs(df);
    this.emaVarDf      = (1-a)*this.emaVarDf      + a*(df*df);
    this.emaAbsU       = (1-a)*this.emaAbsU       + a*Math.abs(u);
    this.emaOneMinConf = (1-a)*this.emaOneMinConf + a*(1 - Math.max(0,Math.min(1,conf)));
    this.emaOneMinIner = (1-a)*this.emaOneMinIner + a*(1 - Math.max(0,Math.min(1,inertia)));
  }

  cost(){
    const sigmaDf = Math.sqrt(Math.max(0, this.emaVarDf));
    return  this.w_phi*this.emaAbsPhi
          + this.w_df *this.emaAbsDf
          + this.w_var*sigmaDf
          + this.w_u  *this.emaAbsU
          + this.w_c  *this.emaOneMinConf
          + this.w_i  *this.emaOneMinIner;
  }

  step(){
    const J = this.cost();             // целевой 0
    const e = -J;                      // хотим J→0 → e = -J
    this.I = Math.max(-this.Imax, Math.min(this.Imax, this.I + this.Ki*e));
    this.aggr += this.Kp*e + this.I;

    // границы агрессивности
    this.aggr = Math.max(0.5, Math.min(2.0, this.aggr));
    return { J, aggr: this.aggr };
  }

  // преобразование (aggr → kp/kv/ki/slew) с учётом fs, conf
  gains(fs, conf){
    const snr = Math.max(0.05, Math.min(1.0, conf));
    // базовая доля полосы от fs
    const baseFrac = 0.035 + 0.025*snr;    // 3.5..6.0% fs (чем чище — шире)
    let bw = fs * baseFrac * this.aggr;    // итоговая полоса
    bw = Math.max(1.5, Math.min(fs/3, bw));

    // демпфирование ζ: больше при шуме (снижает колебания)
    const zeta = 0.8 + 0.5*(1 - snr)*(2.0 - this.aggr)/1.5;  // ≈0.8..1.2

    // непрямой синтез коэффициентов
    const twoPiBw = 2*Math.PI*bw;
    const scale = 1/Math.max(40, fs);
    let kp = (2*zeta*twoPiBw) * scale;
    let kv = (twoPiBw*twoPiBw) * scale * 0.25;
    let ki = kp * 0.12 * (0.25 + 0.75*snr);

    // предел скорости: при чистом сигнале и высокой aggr — выше
    const slew = 10 + 140 * snr * this.aggr; // 10..~290 Hz/s

    // анти-срывы: лёгкое энергосбережение
    const eco = 0.88 + 0.12*snr;
    kp*=eco; kv*=eco; ki*=eco;

    return { kp:Math.max(1e-4,kp), kv:Math.max(1e-5,kv), ki:Math.max(1e-6,ki), slew };
  }
}

/* ====================== Частотный сканер ====================== */
class FrequencyScanner{
  constructor(s){
    this.s=s; this.kf=new Kalman(0,0,0.001,0.008);
    this.vco=0; this.phi=0; this.inertia=0; this.state='SEARCHING';

    this.r=0; this.N=this.s.dynamic_n;
    // авто hopRatio: меньше при высокой fs
    this.hopRatio = Math.min(0.4, Math.max(0.1, 0.9 / Math.sqrt((this.s.actual_fs||60)/60)));
    this.hop=Math.max(8, Math.floor(this.N*this.hopRatio));
    this.booted=false;

    this.win=new Float64Array(this.N);
    this.block=new Float64Array(this.N);
    this.tst=new Float64Array(this.N);
    this._needWin=true;

    this.fmax=50; this.fstep=0.1; this.maxPoints=240;

    this.phase_dead=0.02;
    this.f_ema=0;

    this.out_f=0; this.out_conf=0; this.out_inertia=0; this.out_state='SEARCHING';
    this.out_peak=0; this.dt=0; this.fs=0;

    this.u_int=0; this.u_int_max=3.0;
    this.lastUpdateMs=performance.now();

    // динамические усиления (задаёт тюнер)
    this.kp=0.1; this.kv=0.01; this.ki=0.002; this.slew=40;

    this.tuner = new HomeoTuner();
    this.lastDfApplied = 0;
  }

  _wrap(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }
  _ensureWin(){ if(!this._needWin) return; const N=this.N; for(let n=0;n<N;n++) this.win[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); this._needWin=false; }
  _refresh(){
    if(this.N!==this.s.dynamic_n){
      this.N=this.s.dynamic_n;
      this.hopRatio = Math.min(0.4, Math.max(0.1, 0.9 / Math.sqrt((this.s.actual_fs||60)/60)));
      this.hop=Math.max(8, Math.floor(this.N*this.hopRatio));
      this.win=new Float64Array(this.N); this.block=new Float64Array(this.N); this.tst=new Float64Array(this.N);
      this._needWin=true;
    }
    this._ensureWin();
  }
  needCount(){ return this.booted ? this.hop : this.N; }
  _grab(){
    this._refresh();
    const need=this.needCount();
    const avail=(this.s.widx - this.r) & CpuJitterSampler.MASK;
    if(avail < need) return false;

    for(let i=0;i<this.N;i++){
      const idx=(this.r + i) & CpuJitterSampler.MASK;
      this.block[i]=this.s.rb[idx]*this.win[i];
      this.tst[i]=this.s.ts[idx];
    }
    const total=this.tst[this.N-1]-this.tst[0];
    this.dt=(total/1000)/Math.max(1,(this.N-1));
    this.fs=1.0/Math.max(1e-6,this.dt);

    this.r=(this.r+need) & CpuJitterSampler.MASK;
    this.booted=true;
    return true;
  }
  _evalAt(f){ const g=new Goertzel(); g.init(this.N,this.fs,Math.max(0,Math.min(this.fmax,f))); for(let i=0;i<this.N;i++) g.push(this.block[i]); return g.result(); }

  processOnce(){
    if(!this._grab()) return;

    // сетка частот
    this.fmax = Math.min(100, this.s.actual_fs/2);
    this.fstep= Math.max(0.02, this.fmax/260);

    let fmin=0, fmax=this.fmax, fstep=this.fstep;
    if(this.state==='TRACKING'){
      const span=0.10*this.fmax;
      fmin=Math.max(0, this.vco - span);
      fmax=Math.min(this.fmax, this.vco + span);
      fstep=Math.max(this.fstep/5, 0.01);
    }
    let steps=Math.floor((fmax-fmin)/fstep);
    if(steps>this.maxPoints) fstep=(fmax-fmin)/this.maxPoints;

    // скан и метрики
    let bestF=this.vco, bestMag=-1, best=null, sumMag=0, cnt=0;
    for(let f=fmin; f<=fmax+1e-9; f+=fstep){
      const r=this._evalAt(f);
      sumMag+=r.mag; cnt++;
      if(r.mag>bestMag){bestMag=r.mag; bestF=f; best=r;}
    }
    const avgMag=cnt?(sumMag/cnt):0;
    const cur=best || this._evalAt(this.vco);

    // уверенность/пикообразность
    let local=Number.EPSILON;
    for(let df=-2; df<=2; ++df) local += this._evalAt(this.vco + df*fstep).mag;
    const conf=Math.max(0, Math.min(1, (local>0 ? cur.mag/local : 0)));
    const peak=(avgMag>0)?(cur.mag/avgMag):0;
    this.out_peak=peak;

    // инерция (захват/срыв)
    if(conf>0.07 || peak>1.05) this.inertia += 0.40*(1 - this.inertia);
    else this.inertia *= 0.988;
    this.inertia=Math.max(0, Math.min(1, this.inertia));

    if(this.inertia<0.05 && this.state==='TRACKING') this.state='SEARCHING';
    else if(this.inertia>0.34 && this.state==='SEARCHING'){ this.state='TRACKING'; this.kf.reset(0,0); }

    // в поиске — EMA к лучшей частоте
    if(this.state!=='TRACKING'){
      if(!this.f_ema) this.f_ema=bestF;
      const searchGain=Math.min(0.6, 0.08 + 0.52*Math.min(1,peak/1.2));
      this.f_ema=(1-searchGain)*this.f_ema + searchGain*bestF;
      this.vco=this.f_ema;
    }

    // φ-ошибка (с dead-zone)
    let ephi = this._wrap(cur.ph - this.phi);
    if(Math.abs(ephi) < this.phase_dead) ephi = 0;

    // Калман по фазе
    this.kf.predict(this.dt);
    const rMeas = 0.05 + (1 - conf)*3.0 + (1 - this.inertia)*10.0;
    this.kf.update(ephi, rMeas);
    const u = this.kf.x; // «фазовая» управляемая ошибка

    // ==== Homeostasis: обновление метрик, шаг PI и вычисление усилений ====
    // Шустрость стремления: наблюдаемый «желательный» сдвиг к пиковой частоте
    const df_obs = bestF - this.vco;
    // Управляющее воздействие до ограничения (для метрики усилия)
    let u_ctrl = this.kp*u + this.kv*this.kf.v + this.u_int;

    this.tuner.updateMetrics({ phi:ephi, df:df_obs, u:u_ctrl, conf, inertia:this.inertia });
    const { J, aggr } = this.tuner.step(); // J→0, получаем новую агрессивность
    const g = this.tuner.gains(this.fs, conf); // и коэффициенты из aggr+fs+conf
    this.kp=g.kp; this.kv=g.kv; this.ki=g.ki; const slew=g.slew;

    // интегратор по фазе (дрейф), с анти-windup
    this.u_int += this.ki * ephi * this.dt;
    const uMax=this.u_int_max * (0.8 + 1.2*conf);
    this.u_int=Math.max(-uMax, Math.min(uMax, this.u_int));

    // обновлённое воздействие + ограничение скорости
    u_ctrl = this.kp*u + this.kv*this.kf.v + this.u_int;

    const now=performance.now();
    const dtMs=Math.max(1, now - this.lastUpdateMs);
    this.lastUpdateMs = now;
    const maxStep = slew * (dtMs/1000);

    const df_applied = Math.max(-maxStep, Math.min(maxStep, u_ctrl));
    if(df_applied !== u_ctrl) this.u_int *= 0.95; // анти-windup
    this.lastDfApplied = df_applied;

    // шаг частоты и фазы
    this.vco = Math.max(0, Math.min(this.fmax, this.vco + df_applied));
    this.phi = this._wrap(this.phi + 2*Math.PI*this.vco*this.dt);

    // выходы
    this.out_f=this.vco; this.out_conf=conf; this.out_inertia=this.inertia; this.out_state=this.state;

    // (опционально можно логировать J/aggr, но не засоряем консоль)
    // if ((Math.random()<0.02)) console.log(`J=${J.toFixed(4)} aggr=${aggr.toFixed(2)} kp=${this.kp.toFixed(4)} kv=${this.kv.toFixed(5)} ki=${this.ki.toFixed(5)} slew=${slew.toFixed(0)}`);
  }
}

/* ============================ UI ============================ */
document.addEventListener('DOMContentLoaded',()=>{
  const s=new CpuJitterSampler();
  const scan=new FrequencyScanner(s);
  const blender=new OutputBlender();

  // Мягкая фоновая активность (CPU worker)
  let worker=null;
  try{
    const code=`let it=900,tick=12;
onmessage=e=>{it=e.data.it||it;tick=e.data.dt||tick;};
function step(){let x=1.0001;for(let i=0;i<it;i++){x*=1.00000001;x/=1.000000009;} setTimeout(()=>postMessage(1),tick);}
setInterval(step,12);`;
    worker=new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
    worker.onmessage=()=>{};
  }catch(_){}

  const $=id=>document.getElementById(id);
  const setT=(id,v)=>{const el=$(id); if(el) el.textContent=v;};
  const setW=(id,p)=>{const el=$(id); if(el) el.style.width=Math.max(0,Math.min(100,p)).toFixed(0)+'%';};

  function render(out){
    const fmax=Math.max(1, scan.fmax);
    setT('freqValue', out.f.toFixed(2)); setW('freqBar', 100*out.f/fmax);
    setT('inertiaValue', (out.inertia*100).toFixed(0)); setW('inertiaBar', out.inertia*100);
    setT('confValue', out.conf.toFixed(2)); setW('confBar', out.conf*100);

    const nowStr=new Date().toLocaleTimeString('ru-RU');
    setT('info',
      `Состояние: ${out.state} | f=${out.f.toFixed(3)} Гц | `+
      `Стабильность: ${(out.inertia*100).toFixed(0)}% | Уверенность: ${out.conf.toFixed(2)} | `+
      `fs: ${s.actual_fs.toFixed(1)} Гц | N: ${s.dynamic_n} (hop=${scan.hop}) | `+
      `kp=${scan.kp.toFixed(4)} kv=${scan.kv.toFixed(5)} ki=${scan.ki.toFixed(5)} | `
    );
  }

  function emulateLoad(it){ let x=1.0001; for(let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } }

  function loop(){
    try{
      const needCnt=scan.needCount();
      const avail=((s.widx - scan.r) & CpuJitterSampler.MASK);
      const need = (avail < needCnt);

      if(need){
        for(let i=0;i<180;i++) s.sample();
        if(!worker) emulateLoad(450);
        const fill=Math.min(100, (avail/Math.max(1,needCnt))*100);
        setW('loadingBar', fill);
        setT('statusText', `Плавное накопление… (${fill.toFixed(0)}%)`);
        render(blender.hold());
        return setTimeout(loop, 80);
      }

      scan.processOnce();

      // авто-нагрузка по выраженности пика
      const peak=scan.out_peak||0;
      if(worker){
        const base=700;
        const extra=Math.max(0, Math.min(8000, Math.round((1.0 - Math.min(1, peak/1.2))*6000)));
        worker.postMessage({it: base+extra, dt:12});
      }

      if(s.actual_fs < 45) setT('statusText','Низкая частота сэмплирования (<45 Гц). Добавьте лёгкой активности.');
      else setT('statusText','Анализируется… (homeostasis J→0)');

      render(blender.blend({ f:scan.out_f, conf:scan.out_conf, inertia:scan.out_inertia, state:scan.out_state }));
      setTimeout(loop, 160);
    }catch(e){
      setT('info', `Критическая ошибка: ${e.message}. Обновите страницу.`);
      console.error(e);
      setTimeout(loop, 700);
    }
  }
  loop();
});
</script>
</body>
</html>
