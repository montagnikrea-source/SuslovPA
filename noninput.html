<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <title>Frequency Scanner — Neuro Homeostasis J→0 (with AdSense Auto Ads)</title>

  <!-- (Необязательно, но рекомендуется) Укажи аккаунт AdSense для мета-сканеров -->
  <meta name="google-adsense-account" content="ca-pub-1128500581050725">

  <!-- ✅ Google AdSense Auto Ads (автоматическая реклама) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1128500581050725"
          crossorigin="anonymous"></script>

  <style>
    :root { --bg:#f3f5f7; --panel:#fff; --muted:#556; --bar:#e8ebef; }
    html,body{margin:0;background:var(--bg);font:14px/1.45 system-ui,Segoe UI,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:24px;background:var(--panel);border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07)}
    h1{margin:0 0 10px}
    #loading{margin:6px 0 12px}
    #loading .bg{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    #loading .fill{height:100%;width:0%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);transition:width .25s ease-out}
    #statusText{color:var(--muted);margin-top:6px}
    .row{margin-top:12px}
    .lbl{margin:10px 0 6px}
    .bar{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    .f{height:100%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);width:0%}
    .i{height:100%;background:linear-gradient(90deg,#18b56c 60%,#9ef0c5);width:0%}
    .c{height:100%;background:linear-gradient(90deg,#ff9800 60%,#ffd699);width:0%}
    #info{margin-top:14px;font-family:ui-monospace,Consolas,Menlo,monospace;white-space:pre-wrap;color:#222}
    .hint{color:#444;margin-top:8px}

    /* Резерв высоты под ручной рекламный блок, чтобы верстка не «прыгала» (если решишь включить) */
    .ad-placeholder { min-height: 250px; display:block; text-align:center; margin:16px 0; background:transparent; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Frequency Scanner — Homeostatic Zero-Target (CPU-only, Neuro J→0)</h1>

  <div id="loading">
    <div class="bg"><div id="loadingBar" class="fill"></div></div>
    <div id="statusText">Плавное накопление…</div>
  </div>

  <div class="row">
    <div class="lbl">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
    <div class="bar"><div id="freqBar" class="f"></div></div>

    <div class="lbl">Стабильность (%): <span id="inertiaValue">0</span></div>
    <div class="bar"><div id="inertiaBar" class="i"></div></div>

    <div class="lbl">Уверенность: <span id="confValue">0</span></div>
    <div class="bar"><div id="confBar" class="c"></div></div>
  </div>

  <!-- Панель авт/ручн. настроек нейрообучения -->
  <div class="row controls" style="margin-top:18px;padding:12px;border-radius:12px;background:#f7f9fb;border:1px solid #e7ecf2">
    <div class="lbl" style="margin-top:0">Параметры обучения (онлайн):</div>
    <div style="display:grid;grid-template-columns:180px 1fr 80px 84px;gap:8px;align-items:center">
      <div>Learning rate (lr)</div>
      <input id="lrSlider" type="range" min="0.001" max="0.2" step="0.001" value="0.030"/>
      <div><span id="lrVal">0.030</span></div>
      <label style="display:flex;gap:6px;align-items:center;white-space:nowrap"><input id="lrAuto" type="checkbox" checked/> AUTO</label>

      <div>L2-регуляризация (l2)</div>
      <input id="l2Slider" type="range" min="0.0" max="0.01" step="0.0001" value="0.0001"/>
      <div><span id="l2Val">0.0001</span></div>
      <label style="display:flex;gap:6px;align-items:center;white-space:nowrap"><input id="l2Auto" type="checkbox" checked/> AUTO</label>

      <div>Смешивание NN/PI (mix)</div>
      <input id="mixSlider" type="range" min="0.0" max="1.0" step="0.01" value="0.75"/>
      <div><span id="mixVal">0.75</span></div>
      <label style="display:flex;gap:6px;align-items:center;white-space:nowrap"><input id="mixAuto" type="checkbox" checked/> AUTO</label>
    </div>
    <div class="hint" style="margin-top:8px">AUTO — параметры настраиваются автоматически; снимите флажок, чтобы управлять вручную.</div>
  </div>

  <!-- ────────────────────────────────────────────────────────────────
       НЕОБЯЗАТЕЛЬНЫЙ ручной рекламный блок (Responsive)
       ВНИМАНИЕ: Чтобы заработал, замени data-ad-slot на свой в кабинете AdSense.
       Если хочешь использовать только Auto Ads — оставь этот блок закомментированным.
  <ins class="adsbygoogle ad-placeholder"
       data-ad-client="ca-pub-1128500581050725"
       data-ad-slot="REPLACE_WITH_YOUR_SLOT_ID_1"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
  ───────────────────────────────────────────────────────────────── -->

  <div id="info"></div>
  <div class="hint">Цель автоматики — J→0: |φ|, |Δf|, Var(Δf), |u|, (1−conf), (1−inertia) → 0. Нейро-гомеостаз с lock-защитой и авто/ручным управлением lr/l2/mix.</div>
</div>

<!-- ====== ОПИСАНИЯ (можно оставить как есть) ====== -->
<section id="how-it-works" style="max-width:960px;margin:24px auto;padding:18px 20px;background:#fff;border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07);font:14px/1.55 system-ui,Segoe UI,Arial">
  <h2 style="margin:0 0 12px">Как это работает</h2>
  <p>Приложение измеряет «микродрожание» CPU, извлекает частоты (Goertzel), стабилизирует фазу (Kalman) и онлайновой мини-нейросетью подбирает агрессивность регулятора, стремясь к <b>J→0</b>. Встроена lock-защита от переобучения.</p>
</section>

<section id="use-cases" style="max-width:960px;margin:24px auto;padding:18px 20px;background:#fff;border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07);font:14px/1.55 system-ui,Segoe UI,Arial">
  <h2 style="margin:0 0 12px">Где можно применить</h2>
  <ul style="margin:6px 0 0 18px">
    <li>Стабилизация таймеров/процессов (меньше джиттера → меньше лишнего тепла).</li>
    <li>Мультимедиа/игры: сглаживание лагов и автоподстройка к тикрейту.</li>
    <li>Электроника/ФАПЧ/ШИМ: онлайн-подстройка коэффициентов.</li>
  </ul>
</section>

<!-- ────────────────────────────────────────────────────────────────
     НЕОБЯЗАТЕЛЬНЫЙ ручной рекламный блок внизу страницы (Responsive)
     Замени data-ad-slot на свой. Для Auto Ads это не нужно.
<ins class="adsbygoogle ad-placeholder"
     data-ad-client="ca-pub-1128500581050725"
     data-ad-slot="REPLACE_WITH_YOUR_SLOT_ID_2"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
────────────────────────────────────────────────────────────────── -->

<script>
/* ====================== CPU-сэмплер ====================== */
class CpuJitterSampler {
  static RB_SIZE=16384; static MASK=CpuJitterSampler.RB_SIZE-1;
  constructor(){
    this.rb=new Float64Array(CpuJitterSampler.RB_SIZE);
    this.ts=new Float64Array(CpuJitterSampler.RB_SIZE);
    this.widx=0;
    this.target_ms=2.0; this.iters=800; this.iters_min=120; this.iters_max=150000;
    this.alpha=0.008; this.ema=0; this.rms=0;
    this.dynamic_n=64; this.actual_fs=500;
    this.sample_count=0; this.last_widx=0; this.last_check=performance.now(); this.stall_count=0;
    this._medBuf=new Float64Array(9); this._mi=0; this._mlen=0;
  }
  _kernel(n){let x=1.0001; for(let i=0;i<n;i++){x*=1.00000001; x/=1.000000009;}}
  _median9(x){const n=this._mlen<9?++this._mlen:9; this._medBuf[this._mi]=x; this._mi=(this._mi+1)%9; const t=Array.from(this._medBuf.slice(0,n)).sort((a,b)=>a-b); return t[(n>>1)];}
  sample(){
    const t0=performance.now(); this._kernel(this.iters);
    let dt=performance.now()-t0; dt=this._median9(dt);
    if(!this.ema) this.ema=dt; this.ema=(1-this.alpha)*this.ema+this.alpha*dt;
    const jitter=dt-this.ema; const idx=(this.widx++)&CpuJitterSampler.MASK;
    this.rb[idx]=jitter; this.ts[idx]=t0; this.sample_count++;
    this.rms=(1-this.alpha)*this.rms + this.alpha*jitter*jitter;
    if((this.sample_count & 0x7F)===0){
      const ratio=this.ema/Math.max(0.25,this.target_ms);
      const k=Math.max(0.65,Math.min(1.5,1/ratio));
      this.iters=Math.max(this.iters_min, Math.min(this.iters_max, Math.round(this.iters*k)));
      this.actual_fs=1000/Math.max(0.25,this.ema);
      this.dynamic_n=Math.max(48, Math.min(512, Math.ceil(0.30*this.actual_fs)));
    }
  }
  checkStall(){
    const now=performance.now();
    if(now-this.last_check>1000 && this.widx===this.last_widx){
      this.stall_count++;
      if(this.stall_count>2){
        this.iters=Math.max(this.iters_min,(this.iters/1.8)|0);
        this.target_ms=Math.min(6.0,this.target_ms*1.12);
        this.stall_count=0;
      }
      return true;
    }
    this.last_check=now; this.last_widx=this.widx; this.stall_count=0; return false;
  }
}

/* ======================= Goertzel ======================= */
class Goertzel{
  init(n,fs,f){this.N=n;const k=Math.floor(0.5+n*f/fs);const w=2*Math.PI*k/n;
    this.cw=Math.cos(w); this.sw=Math.sin(w); this.s1=0; this.s2=0;}
  push(x){const s=x+2*this.cw*this.s1 - this.s2; this.s2=this.s1; this.s1=s;}
  result(){const re=this.s1 - this.s2*this.cw, im=this.s2*this.sw;
    const mag=Math.hypot(re,im)/(this.N>1?(this.N/2):1); const ph=Math.atan2(im,re);
    return {mag, ph};
  }
}

/* ===================== OutputBlender ==================== */
class OutputBlender{
  constructor(){this.ready=false;this.ramp=0;this.last={f:0,conf:0,inertia:0,state:'SEARCHING'};}
  blend(cur,step=0.18){ if(!this.ready){this.last={...cur};this.ready=true;this.ramp=Math.min(1,this.ramp+step);return cur;}
    const a=Math.min(1,this.ramp+step);this.ramp=a; const mix=(p,q)=>p*(1-a)+q*a;
    const out={f:mix(this.last.f,cur.f),conf:mix(this.last.conf,cur.conf),inertia:mix(this.last.inertia,cur.inertia),state:cur.state};
    this.last=out; return out;
  }
  hold(step=0.08){ this.ramp=Math.min(1,this.ramp+step); return this.last; }
}

/* ======================== Kalman ======================== */
class Kalman{
  constructor(x0,v0,qpos,qvel){ this.qp=qpos; this.qv=qvel; this.reset(x0,v0); }
  reset(x,v){ this.x=x; this.v=v; this.p00=1; this.p01=0; this.p10=0; this.p11=1; }
  predict(dt){
    this.x += this.v*dt;
    this.p00 += dt*(this.p10+this.p01) + dt*dt*this.p11;
    this.p01 += dt*this.p11; this.p10 += dt*this.p11;
    this.p00 += this.qp; this.p11 += this.qv;
  }
  update(z,r){
    const y=z-this.x, s=this.p00+r; if(Math.abs(s)<1e-9) return;
    const k0=this.p00/s, k1=this.p10/s;
    this.x += k0*y; this.v += k1*y;
    const p00=this.p00, p01=this.p01;
    this.p00 -= k0*p00; this.p01 -= k0*p01;
    this.p10 -= k1*p00; this.p11 -= k1*p01;
  }
}

/* =================== Нейро-гомеостаз (с lock) =================== */
class NeuroHomeo {
  constructor(){
    this.w_phi=1.0; this.w_df=0.8; this.w_var=0.9; this.w_u=0.7; this.w_c=0.9; this.w_i=0.7;
    this.a = 0.12;
    this.emaAbsPhi=0; this.emaAbsDf=0; this.emaVarDf=0; this.emaAbsU=0; this.emaOneMinConf=1; this.emaOneMinIner=1;

    const H=8; const D=9; this.H=H; this.D=D;
    this.W1=new Float64Array(H*D); this.b1=new Float64Array(H);
    this.W2=new Float64Array(H);     this.b2=0;
    const r1=Math.sqrt(2/(D)); for(let i=0;i<H*D;i++) this.W1[i]=(Math.random()*2-1)*r1;
    for(let i=0;i<H;i++) this.b1[i]=0;
    const r2=Math.sqrt(2/(H)); for(let i=0;i<H;i++) this.W2[i]=(Math.random()*2-1)*r2;
    this.b2=0;

    this.lr=0.03; this.l2=1e-4; this.mix=0.75; // авто/ручное управление ниже
    this.aggr=1.0; this.I=0; this.Imax=3.0; this.Kp=0.35; this.Ki=0.10;
    this.prevJ=null; this.prevAggr=null; this.eps=1e-6;
    this._x=new Float64Array(D); this._h=new Float64Array(H); this._h_lin=new Float64Array(H);

    // lock-защита
    this.locked=false; this.lockUntil=0; this.lockMs=3000;
    this.lrBase=this.lr; this.lrMin=0.003; this.lrRecoverMs=3000; this.lastUnlockTime=performance.now();
    this.snap=null;
    this.spikeJ=0.25; this.dropC=0.25;
  }
  snapshot(){ this.snap={ W1:new Float64Array(this.W1), b1:new Float64Array(this.b1), W2:new Float64Array(this.W2), b2:this.b2, aggr:this.aggr }; }
  restore(){ if(this.snap){ this.W1.set(this.snap.W1); this.b1.set(this.snap.b1); this.W2.set(this.snap.W2); this.b2=this.snap.b2; this.aggr=this.snap.aggr; } }

  _features({phi, df, u, conf, inertia, fs, peak}){
    const clip=(v,a,b)=>Math.max(a,Math.min(b,v));
    const mphi=clip(Math.abs(phi)/Math.PI, 0, 1);
    const mdf =clip(Math.abs(df)/50, 0, 1);
    const mu  =clip(Math.abs(u)/300, 0, 1);
    const mc  =clip(1-conf, 0, 1);
    const mi  =clip(1-inertia, 0, 1);
    const mfs =clip(fs/240, 0, 1);
    const mpk =clip(peak/2.5, 0, 1);
    const sDf =clip(Math.sqrt(Math.max(0,this.emaVarDf))/50, 0, 1);
    this._x.set([1, mphi, mdf, sDf, mu, mc, mi, mfs, mpk]);
    return this._x;
  }
  updateMetrics({phi, df, u, conf, inertia}){
    const a=this.a;
    this.emaAbsPhi = (1-a)*this.emaAbsPhi + a*Math.abs(phi);
    this.emaAbsDf  = (1-a)*this.emaAbsDf  + a*Math.abs(df);
    this.emaVarDf  = (1-a)*this.emaVarDf  + a*(df*df);
    this.emaAbsU   = (1-a)*this.emaAbsU   + a*Math.abs(u);
    this.emaOneMinConf = (1-a)*this.emaOneMinConf + a*(1 - Math.max(0,Math.min(1,conf)));
    this.emaOneMinIner = (1-a)*this.emaOneMinIner + a*(1 - Math.max(0,Math.min(1,inertia)));
  }
  cost(){
    const sigmaDf = Math.sqrt(Math.max(0, this.emaVarDf));
    return  this.w_phi*this.emaAbsPhi + this.w_df*this.emaAbsDf + this.w_var*sigmaDf
          + this.w_u*this.emaAbsU + this.w_c*this.emaOneMinConf + this.w_i*this.emaOneMinIner;
  }
  _forward(x){
    const H=this.H, D=this.D; const h=this._h, hl=this._h_lin;
    for(let i=0;i<H;i++){
      let s=this.b1[i]; const off=i*D; for(let j=0;j<D;j++) s+=this.W1[off+j]*x[j];
      hl[i]=s; h[i]=Math.tanh(s);
    }
    let y=this.b2; for(let i=0;i<H;i++) y+=this.W2[i]*h[i];
    const aggr = 0.5 + 1.5*(1/(1+Math.exp(-y)));
    return {y, aggr};
  }
  _backward(dJdy){
    const H=this.H, D=this.D, x=this._x, h=this._h, hl=this._h_lin;
    const dJdb2 = dJdy; for(let i=0;i<H;i++){ const dW2 = dJdy * h[i] + this.l2*this.W2[i]; this.W2[i] -= this.lr * dW2; }
    this.b2 -= this.lr * dJdb2;
    const dJdh = new Float64Array(H); for(let i=0;i<H;i++) dJdh[i] = dJdy * this.W2[i];
    for(let i=0;i<H;i++){
      const sech2 = 1 - Math.tanh(hl[i])**2; const g = dJdh[i]*sech2; const off=i*D;
      for(let j=0;j<D;j++){ const dW1 = g * x[j] + this.l2*this.W1[off+j]; this.W1[off+j] -= this.lr * dW1; }
      this.b1[i] -= this.lr * g;
    }
  }
  maybeLock(J, conf, inertia){
    const now=performance.now();
    if(this.prevJ==null){ this.snapshot(); return; }
    const relSpike = (J - this.prevJ) / Math.max(1e-6, Math.abs(this.prevJ));
    const poor = ((1-conf) > this.dropC) || ((1-inertia) > this.dropC);
    if(relSpike > this.spikeJ && poor){
      this.restore();
      this.locked = true; this.lockUntil = now + this.lockMs;
      this.lr = Math.max(this.lrMin, this.lrBase*0.25);
    }
    if(this.locked && now >= this.lockUntil){
      this.locked = false; this.lastUnlockTime = now;
    }
  }
  recoverLr(){
    if(this.locked) return;
    const t = Math.min(1, (performance.now() - this.lastUnlockTime)/this.lrRecoverMs);
    this.lr = this.lrBase*(0.25 + 0.75*t);
  }
  step(state){
    const {phi, df, u, conf, inertia, fs, peak} = state;
    const x = this._features({phi, df, u, conf, inertia, fs, peak});
    const {y, aggr:aggr_nn} = this._forward(x);

    const J = this.cost();
    this.maybeLock(J, conf, inertia);

    const e = -J; this.I = Math.max(-this.Imax, Math.min(this.Imax, this.I + this.Ki*e));
    let aggr_pi = this.aggr + this.Kp*e + this.I; aggr_pi = Math.max(0.5, Math.min(2.0, aggr_pi));

    let aggr;
    if(this.locked){ aggr = aggr_pi; }
    else {
      const noise = (Math.random()*2-1)*0.03;
      aggr = Math.max(0.5, Math.min(2.0, this.mix*aggr_nn + (1-this.mix)*aggr_pi + noise));
    }

    if(!this.locked && this.prevJ!==null && this.prevAggr!==null){
      const dJdaggr = (J - this.prevJ) / (aggr - this.prevAggr + this.eps);
      const sig = 1/(1+Math.exp(-y));
      const daggr_dy = 1.5*sig*(1-sig) + 1e-6;
      let dJdy = dJdaggr * daggr_dy; dJdy = Math.max(-5, Math.min(5, dJdy));
      this._backward(dJdy);
    }

    if(!this.locked) this.snapshot();
    this.recoverLr();

    this.prevJ = J; this.prevAggr = aggr; this.aggr = aggr;

    const snr = Math.max(0.05, Math.min(1.0, conf));
    const baseFrac = 0.035 + 0.025*snr; let bw = fs * baseFrac * aggr; bw = Math.max(1.5, Math.min(fs/3, bw));
    const zeta = 0.8 + 0.5*(1 - snr)*(2.0 - aggr)/1.5; const twoPiBw = 2*Math.PI*bw; const scale = 1/Math.max(40, fs);
    let kp = (2*zeta*twoPiBw) * scale; let kv = (twoPiBw*twoPiBw) * scale * 0.25; let ki = kp * 0.12 * (0.25 + 0.75*snr);
    const slew = 10 + 140 * snr * aggr; const eco = 0.88 + 0.12*snr; kp*=eco; kv*=eco; ki*=eco;
    return { J, aggr, kp:Math.max(1e-4,kp), kv:Math.max(1e-5,kv), ki:Math.max(1e-6,ki), slew };
  }
}

/* ====================== Частотный сканер ====================== */
class FrequencyScanner{
  constructor(s){
    this.s=s; this.kf=new Kalman(0,0,0.001,0.008);
    this.vco=0; this.phi=0; this.inertia=0; this.state='SEARCHING';

    this.r=0; this.N=this.s.dynamic_n;
    this.hopRatio = Math.min(0.4, Math.max(0.1, 0.9 / Math.sqrt((this.s.actual_fs||60)/60)));
    this.hop=Math.max(8, Math.floor(this.N*this.hopRatio));
    this.booted=false;

    this.win=new Float64Array(this.N);
    this.block=new Float64Array(this.N);
    this.tst=new Float64Array(this.N);
    this._needWin=true;

    this.fmax=50; this.fstep=0.1; this.maxPoints=240;

    this.phase_dead=0.02;
    this.f_ema=0;

    this.out_f=0; this.out_conf=0; this.out_inertia=0; this.out_state='SEARCHING';
    this.out_peak=0; this.dt=0; this.fs=0;

    this.u_int=0; this.u_int_max=3.0;
    this.lastUpdateMs=performance.now();

    this.kp=0.1; this.kv=0.01; this.ki=0.002; this.slew=40;

    this.tuner = new NeuroHomeo();
    this.lastDfApplied = 0;
  }

  _wrap(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }
  _ensureWin(){ if(!this._needWin) return; const N=this.N; for(let n=0;n<N;n++) this.win[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); this._needWin=false; }
  _refresh(){
    if(this.N!==this.s.dynamic_n){
      this.N=this.s.dynamic_n;
      this.hopRatio = Math.min(0.4, Math.max(0.1, 0.9 / Math.sqrt((this.s.actual_fs||60)/60)));
      this.hop=Math.max(8, Math.floor(this.N*this.hopRatio));
      this.win=new Float64Array(this.N); this.block=new Float64Array(this.N); this.tst=new Float64Array(this.N);
      this._needWin=true;
    }
    this._ensureWin();
  }
  needCount(){ return this.booted ? this.hop : this.N; }
  _grab(){
    this._refresh();
    const need=this.needCount();
    const avail=(this.s.widx - this.r) & CpuJitterSampler.MASK;
    if(avail < need) return false;

    for(let i=0;i<this.N;i++){
      const idx=(this.r + i) & CpuJitterSampler.MASK;
      this.block[i]=this.s.rb[idx]*this.win[i];
      this.tst[i]=this.s.ts[idx];
    }
    const total=this.tst[this.N-1]-this.tst[0];
    this.dt=(total/1000)/Math.max(1,(this.N-1));
    this.fs=1.0/Math.max(1e-6,this.dt);

    this.r=(this.r+need) & CpuJitterSampler.MASK;
    this.booted=true;
    return true;
  }
  _evalAt(f){ const g=new Goertzel(); g.init(this.N,this.fs,Math.max(0,Math.min(this.fmax,f))); for(let i=0;i<this.N;i++) g.push(this.block[i]); return g.result(); }

  processOnce(){
    if(!this._grab()) return;

    this.fmax = Math.min(100, this.s.actual_fs/2);
    this.fstep= Math.max(0.02, this.fmax/260);

    let fmin=0, fmax=this.fmax, fstep=this.fstep;
    if(this.state==='TRACKING'){
      const span=0.10*this.fmax;
      fmin=Math.max(0, this.vco - span);
      fmax=Math.min(this.fmax, this.vco + span);
      fstep=Math.max(this.fstep/5, 0.01);
    }
    let steps=Math.floor((fmax-fmin)/fstep);
    if(steps>this.maxPoints) fstep=(fmax-fmin)/this.maxPoints;

    let bestF=this.vco, bestMag=-1, best=null, sumMag=0, cnt=0;
    for(let f=fmin; f<=fmax+1e-9; f+=fstep){
      const r=this._evalAt(f);
      sumMag+=r.mag; cnt++;
      if(r.mag>bestMag){bestMag=r.mag; bestF=f; best=r;}
    }
    const avgMag=cnt?(sumMag/cnt):0;
    const cur=best || this._evalAt(this.vco);

    let local=Number.EPSILON;
    for(let df=-2; df<=2; ++df) local += this._evalAt(this.vco + df*fstep).mag;
    const conf=Math.max(0, Math.min(1, (local>0 ? cur.mag/local : 0)));
    const peak=(avgMag>0)?(cur.mag/avgMag):0;
    this.out_peak=peak;

    if(conf>0.07 || peak>1.05) this.inertia += 0.40*(1 - this.inertia);
    else this.inertia *= 0.988;
    this.inertia=Math.max(0, Math.min(1, this.inertia));

    if(this.inertia<0.05 && this.state==='TRACKING') this.state='SEARCHING';
    else if(this.inertia>0.34 && this.state==='SEARCHING'){ this.state='TRACKING'; this.kf.reset(0,0); }

    if(this.state!=='TRACKING'){
      if(!this.f_ema) this.f_ema=bestF;
      const searchGain=Math.min(0.6, 0.08 + 0.52*Math.min(1,peak/1.2));
      this.f_ema=(1-searchGain)*this.f_ema + searchGain*bestF;
      this.vco=this.f_ema;
    }

    let ephi = this._wrap(cur.ph - this.phi);
    if(Math.abs(ephi) < this.phase_dead) ephi = 0;

    this.kf.predict(this.dt);
    const rMeas = 0.05 + (1 - conf)*3.0 + (1 - this.inertia)*10.0;
    this.kf.update(ephi, rMeas);
    const u = this.kf.x;

    const df_obs = bestF - this.vco;
    let u_ctrl = this.kp*u + this.kv*this.kf.v + this.u_int;

    // авто/ручные параметры (берём из UI)
    // применяются в основном цикле перед processOnce()

    // шаг тюнера (даёт новые kp/kv/ki/slew)
    const neu = this.tuner.step({
      phi:ephi, df:df_obs, u:u_ctrl, conf, inertia:this.inertia, fs:this.fs, peak
    });

    this.u_int += neu.ki * ephi * this.dt;
    const uMax=this.u_int_max * (0.8 + 1.2*conf);
    this.u_int=Math.max(-uMax, Math.min(uMax, this.u_int));

    u_ctrl = neu.kp*u + neu.kv*this.kf.v + this.u_int;

    const now=performance.now();
    const dtMs=Math.max(1, now - this.lastUpdateMs);
    this.lastUpdateMs = now;
    const maxStep = neu.slew * (dtMs/1000);

    const df_applied = Math.max(-maxStep, Math.min(maxStep, u_ctrl));
    if(df_applied !== u_ctrl) this.u_int *= 0.95;
    this.lastDfApplied = df_applied;

    this.vco = Math.max(0, Math.min(this.fmax, this.vco + df_applied));
    this.phi = this._wrap(this.phi + 2*Math.PI*this.vco*this.dt);

    this.kp=neu.kp; this.kv=neu.kv; this.ki=neu.ki; this.slew=neu.slew;

    this.out_f=this.vco; this.out_conf=conf; this.out_inertia=this.inertia; this.out_state=this.state;
  }
}

/* ============================ UI ============================ */
document.addEventListener('DOMContentLoaded',()=>{
  const s=new CpuJitterSampler();
  const scan=new FrequencyScanner(s);
  const blender=new OutputBlender();

  // Мягкая фоновая активность (CPU worker)
  let worker=null;
  try{
    const code=`let it=900,tick=12;
onmessage=e=>{it=e.data.it||it;tick=e.data.dt||tick;};
function step(){let x=1.0001;for(let i=0;i<it;i++){x*=1.00000001;x/=1.000000009;} setTimeout(()=>postMessage(1),tick);}
setInterval(step,12);`;
    worker=new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
    worker.onmessage=()=>{};
  }catch(_){}

  const $=id=>document.getElementById(id);
  const setT=(id,v)=>{const el=$(id); if(el) el.textContent=v;};
  const setW=(id,p)=>{const el=$(id); if(el) el.style.width=Math.max(0,Math.min(100,p)).toFixed(0)+'%';};

  // === Слайдеры и авто-режимы ===
  const lrSlider=$('lrSlider');
  const l2Slider=$('l2Slider');
  const mixSlider=$('mixSlider');
  const lrVal=$('lrVal'); const l2Val=$('l2Val'); const mixVal=$('mixVal');
  const lrAuto=$('lrAuto'); const l2Auto=$('l2Auto'); const mixAuto=$('mixAuto');

  // Диапазоны для авто-настройки
  const AUTO = { lrMin:0.005, lrMax:0.080, l2Min:0.00005, l2Max:0.0030, mixMin:0.30, mixMax:0.95 };

  function weightsNorm2(t){
    let ssum=0; for(let i=0;i<t.W1.length;i++) ssum+=t.W1[i]*t.W1[i];
    for(let i=0;i<t.W2.length;i++) ssum+=t.W2[i]*t.W2[i];
    return Math.sqrt(ssum/(t.W1.length+t.W2.length));
  }

  function render(out){
    const fmax=Math.max(1, scan.fmax);
    setT('freqValue', out.f.toFixed(2)); setW('freqBar', 100*out.f/fmax);
    setT('inertiaValue', (out.inertia*100).toFixed(0)); setW('inertiaBar', out.inertia*100);
    setT('confValue', out.conf.toFixed(2)); setW('confBar', out.conf*100);

    setT('info',
      `Состояние: ${out.state} | f=${out.f.toFixed(3)} Гц | `+
      `Стабильность: ${(out.inertia*100).toFixed(0)}% | Уверенность: ${out.conf.toFixed(2)} | `+
      `fs: ${s.actual_fs.toFixed(1)} Гц | N: ${s.dynamic_n} (hop=${scan.hop}) | `+
      `kp=${scan.kp.toFixed(4)} kv=${scan.kv.toFixed(5)} ki=${scan.ki.toFixed(5)}`
    );
  }

  function emulateLoad(it){ let x=1.0001; for(let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } }

  function loop(){
    try{
      const needCnt=scan.needCount();
      const avail=((s.widx - scan.r) & CpuJitterSampler.MASK);
      const need = (avail < needCnt);

      if(need){
        for(let i=0;i<180;i++) s.sample();
        if(!worker) emulateLoad(450);
        const fill=Math.min(100, (avail/Math.max(1,needCnt))*100);
        setW('loadingBar', fill);
        setT('statusText', `Плавное накопление… (${fill.toFixed(0)}%)`);
        render(blender.hold());
        return setTimeout(loop, 80);
      }

      // === AUTO/Manual применение параметров перед шагом ===
      const confPrev = scan.out_conf || 0;
      const inerPrev = scan.out_inertia || 0;
      const peakPrev = scan.out_peak || 0;
      const Jprev    = scan.tuner.prevJ;

      // lr
      if(lrAuto && lrAuto.checked){
        let trend = 0; if(Jprev!=null && scan.tuner._lastJforAuto!=null){ trend = (scan.tuner._lastJforAuto - Jprev); }
        scan.tuner._lastJforAuto = Jprev==null ? 0 : Jprev;
        const stability = Math.min(1, Math.max(0, 0.5*confPrev + 0.5*inerPrev));
        const speedBias = (trend>0 ? 0.2 : (trend<0 ? -0.2 : 0));
        let lrAutoVal = AUTO.lrMin + (AUTO.lrMax-AUTO.lrMin)*(0.65*stability + 0.35*Math.max(0,peakPrev/2.0)) + speedBias*(AUTO.lrMax-AUTO.lrMin)*0.25;
        if(scan.tuner.locked) lrAutoVal = Math.max(AUTO.lrMin, lrAutoVal*0.3);
        lrAutoVal = Math.min(AUTO.lrMax, Math.max(AUTO.lrMin, lrAutoVal));
        scan.tuner.lrBase = lrAutoVal;
        lrSlider.value = lrAutoVal.toFixed(3);
        lrVal.textContent = lrAutoVal.toFixed(3) + ' (auto)';
      } else {
        scan.tuner.lrBase = parseFloat(lrSlider.value);
        lrVal.textContent = parseFloat(lrSlider.value).toFixed(3);
      }

      // l2
      if(l2Auto && l2Auto.checked){
        const wnorm = weightsNorm2(scan.tuner);
        const poor  = (1-confPrev)+(1-inerPrev);
        let l2AutoVal = AUTO.l2Min + (AUTO.l2Max-AUTO.l2Min)*(0.6*poor + 0.4*Math.min(1, wnorm/0.8));
        if(scan.tuner.locked) l2AutoVal = Math.min(AUTO.l2Max, l2AutoVal*1.4);
        l2AutoVal = Math.min(AUTO.l2Max, Math.max(AUTO.l2Min, l2AutoVal));
        scan.tuner.l2 = l2AutoVal;
        l2Slider.value = l2AutoVal.toFixed(4);
        l2Val.textContent = l2AutoVal.toFixed(4) + ' (auto)';
      } else {
        scan.tuner.l2 = parseFloat(l2Slider.value);
        l2Val.textContent = parseFloat(l2Slider.value).toFixed(4);
      }

      // mix
      if(mixAuto && mixAuto.checked){
        const stability = Math.min(1, Math.max(0, 0.5*confPrev + 0.5*inerPrev));
        let mixAutoVal = 0.30 + (0.95-0.30)*stability;
        if(scan.tuner.locked) mixAutoVal = Math.max(0.30, mixAutoVal*0.6);
        mixAutoVal = Math.min(0.95, Math.max(0.30, mixAutoVal));
        scan.tuner.mix = mixAutoVal;
        mixSlider.value = mixAutoVal.toFixed(2);
        mixVal.textContent = mixAutoVal.toFixed(2) + ' (auto)';
      } else {
        scan.tuner.mix = parseFloat(mixSlider.value);
        mixVal.textContent = parseFloat(mixSlider.value).toFixed(2);
      }

      // Основной шаг
      scan.processOnce();

      // авто-нагрузка CPU для устойчивой частоты сэмплирования
      const peak=scan.out_peak||0;
      if(worker){
        const base=700;
        const extra=Math.max(0, Math.min(8000, Math.round((1.0 - Math.min(1, peak/1.2))*6000)));
        worker.postMessage({it: base+extra, dt:12});
      }

      if(s.actual_fs < 45) setT('statusText','Низкая частота сэмплирования (<45 Гц). Добавьте лёгкой активности.');
      else setT('statusText','Анализируется… (neuro-homeostasis J→0)');

      render(blender.blend({ f:scan.out_f, conf:scan.out_conf, inertia:scan.out_inertia, state:scan.out_state }));
      setTimeout(loop, 160);
    }catch(e){
      setT('info', `Критическая ошибка: ${e.message}. Обновите страницу.`);
      console.error(e);
      setTimeout(loop, 700);
    }
  }
  loop();
});
</script>

</body>
</html>
