<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noninput Page — GPU/CPU Sync Demo</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #glcanvas { border: 1px solid #ccc; width: 512px; height: 512px; }
        pre { background:#f6f6f6; padding:10px; }
        .status { margin-top:10px; }
    </style>
</head>
<body>
    <header>
        <h1>Добро пожаловать на страницу Noninput</h1>
    </header>
    <main>
        <section>
            <h2>Описание</h2>
            <p>Эта страница содержит демонстрацию синхронизации GPU и CPU в браузере с помощью WebGL2 и sync objects (fenceSync / clientWaitSync).</p>
            <p>Нажмите кнопку ниже, чтобы выполнить рендер на GPU, установить fence и дождаться завершения работа GPU на стороне CPU, а затем считать пиксели обратно на CPU.</p>
        </section>

        <section>
            <h2>Демо синхронизации</h2>
            <button id="runBtn">Запустить GPU→CPU синхронизацию</button>
            <div class="status" id="status">Статус: готов</div>
            <canvas id="glcanvas" width="512" height="512"></canvas>
            <h3>Результат (первые 8 байт RGBA):</h3>
            <pre id="pixels">—</pre>
        </section>

        <section>
            <h2>Изображения</h2>
            <img src="image.jpg" alt="Пример изображения">
        </section>
        <section>
            <h2>Ссылки</h2>
            <p>Вы можете узнать больше о проекте по следующим ссылкам:</p>
            <ul>
                <li><a href="https://github.com/montagnikrea-source/SuslovPA">GitHub репозиторий</a></li>
                <li><a href="index.html">Главная страница</a></li>
            </ul>
        </section>
    </main>
    <footer>
        <p>&copy; 2023 SuslovPA. Все права защищены.</p>
    </footer>

    <script>
    // Проверяем поддержку WebGL2
    const canvas = document.getElementById('glcanvas');
    const statusEl = document.getElementById('status');
    const pixelsEl = document.getElementById('pixels');
    const runBtn = document.getElementById('runBtn');

    function logStatus(msg) {
        statusEl.textContent = 'Статус: ' + msg;
        console.log(msg);
    }

    runBtn.addEventListener('click', async () => {
        runBtn.disabled = true;
        pixelsEl.textContent = '—';
        if (!window.WebGL2RenderingContext) {
            logStatus('WebGL2 не поддерживается в этом браузере.');
            runBtn.disabled = false;
            return;
        }

        const gl = canvas.getContext('webgl2');
        if (!gl) {
            logStatus('Не удалось получить контекст WebGL2.');
            runBtn.disabled = false;
            return;
        }

        try {
            await performGpuCpuSync(gl);
        } catch (e) {
            logStatus('Ошибка: ' + e.message);
            console.error(e);
        }
        runBtn.disabled = false;
    });

    // Создаем шейдеры и программу (простой фрагмент, рисующий градиент)
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error('Не удалось скомпилировать шейдер: ' + info);
        }
        return shader;
    }

    function createProgram(gl, vsSrc, fsSrc) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            const info = gl.getProgramInfoLog(prog);
            gl.deleteProgram(prog);
            throw new Error('Не удалось линковать программу: ' + info);
        }
        return prog;
    }

    async function performGpuCpuSync(gl) {
        logStatus('Создаем ресурсы и рисуем на GPU...');

        const vs = `#version 300 es
        in vec2 a_position;
        out vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }`;

        const fs = `#version 300 es
        precision highp float;
        in vec2 v_uv;
        out vec4 outColor;
        void main() {
            // простой цветной градиент, зависящий от координат
            outColor = vec4(v_uv, 0.5 + 0.5 * sin(v_uv.x * 10.0), 1.0);
        }`;

        const program = createProgram(gl, vs, fs);
        gl.useProgram(program);

        // fullscreen triangle
        const quad = new Float32Array([-1, -1, 3, -1, -1, 3]);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Создаем и привязываем FBO
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            throw new Error('FBO не в состоянии COMPLETE: ' + status);
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Рисуем
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        // Вставляем fence — маркер окончания команд на GPU
        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        // Убедимся, что команды отправлены
        gl.flush();

        logStatus('Fence установлен — ожидаем завершения работы GPU...');

        // Алгоритм синхронизации: неблокирующая проверка клиентом с интервалом
        // Это демонстрационный алгоритм: CPU опрашивает статус sync-объекта, чтобы не блокировать главный поток.
        await waitForGpu(gl, sync);

        logStatus('GPU завершил работу. Считываем пиксели на CPU...');

        // Чтение пикселей с FBO на CPU (readPixels гарантированно будет содержать данные после завершения GPU при sync)
        const pixels = new Uint8Array(canvas.width * canvas.height * 4);
        gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        // Покажем первые несколько байт в интерфейсе
        const firstBytes = Array.from(pixels.slice(0, 8)).map(b => b.toString()).join(', ');
        pixelsEl.textContent = firstBytes;

        // Очистка ресурсов
        gl.deleteSync(sync);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(fbo);
        gl.deleteTexture(tex);
        gl.deleteBuffer(buf);
        gl.deleteProgram(program);
        gl.deleteVertexArray(vao);

        logStatus('Готово — данные считаны и ресурсы очищены.');
    }

    // waitForGpu выполняет опрос status sync-объекта, чтобы дождаться завершения GPU.
    // Использует clientWaitSync с нулевым ожиданием и периодическую проверку через requestAnimationFrame,
    // чтобы не блокировать основной поток длительное время.
    function waitForGpu(gl, sync) {
        return new Promise((resolve, reject) => {
            if (!sync) return reject(new Error('Sync object не создан'));

            function poll() {
                // clientWaitSync возвращает один из статусов
                // gl.CONDITION_SATISFIED или gl.ALREADY_SIGNALED — GPU завершил работу
                const res = gl.clientWaitSync(sync, 0, 0);
                if (res === gl.CONDITION_SATISFIED || res === gl.ALREADY_SIGNALED) {
                    resolve();
                } else if (res === gl.WAIT_FAILED) {
                    reject(new Error('clientWaitSync вернул WAIT_FAILED'));
                } else {
                    // Еще не готово; продолжаем опрашивать в следующем кадре
                    // Можно добавить backoff / увеличение интервала, если нужно
                    requestAnimationFrame(poll);
                }
            }
            poll();
        });
    }

    </script>
</body>
</html>