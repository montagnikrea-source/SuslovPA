<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frequency Scanner Web App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        h1 { margin-bottom: 10px; }
        #desc { margin-bottom: 20px; color: #555; }
        #loading { color: #888; margin-bottom: 10px; }
        .bar-container { width: 100%; max-width: 600px; margin: 20px auto; }
        .bar-label { margin-bottom: 5px; font-size: 16px; color: #333; }
        .bar-bg { width: 100%; height: 32px; background: #eee; border-radius: 8px; overflow: hidden; margin-bottom: 20px; }
        .bar-fill { height: 100%; transition: width 0.3s; }
        #info { margin-top: 20px; font-size: 16px; }
        .freq { background: linear-gradient(90deg, #007bff 60%, #66bfff); }
        .inertia { background: linear-gradient(90deg, #28a745 60%, #7be88b); }
        .conf { background: linear-gradient(90deg, #dc3545 60%, #ffb3b3); }
    </style>
</head>
<body>
    <h1>Frequency Scanner Web App</h1>
    <div id="desc">Веб‑приложение для анализа частоты и инерции на основе jitter-сэмплирования.<br>Шкалы обновляются в реальном времени.</div>
    <div id="loading">Загрузка данных...</div>
    <div class="bar-container">
        <div class="bar-label">Частота (Hz): <span id="freqValue">0</span></div>
        <div class="bar-bg"><div class="bar-fill freq" id="freqBar" style="width:0%"></div></div>
        <div class="bar-label">Инерция (%): <span id="inertiaValue">0</span></div>
        <div class="bar-bg"><div class="bar-fill inertia" id="inertiaBar" style="width:0%"></div></div>
        <div class="bar-label">Достоверность: <span id="confValue">0</span></div>
        <div class="bar-bg"><div class="bar-fill conf" id="confBar" style="width:0%"></div></div>
    </div>
    <div id="info"></div>
    <script>
        // MathJitterSampler
        class MathJitterSampler {
            static FS = 4000.0;
            static N = 2048;
            static RB_SIZE = 16384;
            static MASK = this.RB_SIZE - 1;

            constructor() {
                this.rb = new Array(this.constructor.RB_SIZE).fill(0);
                this.widx = 0;
                this.ema_iterations = 0;
                this.alpha = 0.0025;
                this.run_benchmark(performance.now() + 0.25);
            }

            run_benchmark(endTime) {
                let count = 0;
                let x = 1.0001;
                while (performance.now() < endTime) {
                    x *= 1.00000001;
                    x /= 1.000000009;
                    count++;
                }
                return count;
            }

            sample() {
                let endTime = performance.now() + 0.25;
                let iterations = this.run_benchmark(endTime);
                if (this.ema_iterations === 0) {
                    this.ema_iterations = iterations;
                }
                this.ema_iterations = (1.0 - this.alpha) * this.ema_iterations + this.alpha * iterations;
                let jitter = iterations - this.ema_iterations;
                this.rb[(this.widx++ & this.constructor.MASK)] = jitter;
            }
        }

        // Goertzel
        class Goertzel {
            constructor() {
                this.N = 0;
                this.cw = 0;
                this.sw = 0;
                this.s1 = 0;
                this.s2 = 0;
            }

            init(n, fs, f) {
                this.N = n;
                let k = Math.floor(0.5 + n * f / fs);
                let w = 2.0 * Math.PI * k / n;
                this.cw = Math.cos(w);
                this.sw = Math.sin(w);
                this.s1 = 0;
                this.s2 = 0;
            }

            push(x) {
                let s = x + 2.0 * this.cw * this.s1 - this.s2;
                this.s2 = this.s1;
                this.s1 = s;
            }

            result() {
                let re = this.s1 - this.s2 * this.cw;
                let im = this.s2 * this.sw;
                let denom = this.N > 1 ? this.N / 2.0 : 1.0;
                let m2 = re * re + im * im;
                let mag = Math.sqrt(m2 < 0 ? 0 : m2) / denom;
                let ph = Math.atan2(im, re);
                this.s1 = 0;
                this.s2 = 0;
                return { re, im, mag, ph };
            }
        }

        // KalmanFilter
        class KalmanFilter {
            constructor(initialValue, initialVelocity, processNoisePos, processNoiseVel) {
                this.q_pos = processNoisePos;
                this.q_vel = processNoiseVel;
                this.reset(initialValue, initialVelocity);
            }

            reset(value, velocity) {
                this.x_hat = value;
                this.x_vel = velocity;
                this.p_00 = 1.0;
                this.p_01 = 0.0;
                this.p_10 = 0.0;
                this.p_11 = 1.0;
            }

            predict(dt) {
                this.x_hat += this.x_vel * dt;
                this.p_00 += dt * (this.p_10 + this.p_01) + dt * dt * this.p_11;
                this.p_01 += dt * this.p_11;
                this.p_10 += dt * this.p_11;
                this.p_00 += this.q_pos;
                this.p_11 += this.q_vel;
            }

            update(z_meas, r_meas_noise) {
                let y = z_meas - this.x_hat;
                let s = this.p_00 + r_meas_noise;
                if (Math.abs(s) < 1e-9) return;
                let k_0 = this.p_00 / s;
                let k_1 = this.p_10 / s;
                this.x_hat += k_0 * y;
                this.x_vel += k_1 * y;
                let p_00_temp = this.p_00, p_01_temp = this.p_01;
                this.p_00 -= k_0 * p_00_temp;
                this.p_01 -= k_0 * p_01_temp;
                this.p_10 -= k_1 * p_00_temp;
                this.p_11 -= k_1 * p_01_temp;
            }

            getValue() {
                return this.x_hat;
            }
        }

        // FrequencyScanner
        class FrequencyScanner {
            // Автоматизация констант на основе параметров и данных
            static F_MIN = 0.0;
            static F_MAX = Math.min(400, MathJitterSampler.FS / 10);
            static F_STEP = Math.max(0.1, FrequencyScanner.F_MAX / 800);
            static FS = MathJitterSampler.FS;
            static N = MathJitterSampler.N;
            static DT_WIN = FrequencyScanner.N / FrequencyScanner.FS;
            static EPSILON = Number.EPSILON;
            static K_VCO = Math.max(0.05, 0.5 / FrequencyScanner.F_MAX);

            // Автоматизация порога и коэффициентов инерции
            static INERTIA_THRESHOLD = Math.max(0.05, 0.2 - 0.1 * (FrequencyScanner.F_MAX / 400)); // Чем ниже F_MAX, тем ниже порог
            static INERTIA_GAIN = Math.min(1.0, 0.5 / FrequencyScanner.INERTIA_THRESHOLD); // Чем ниже порог, тем больше прирост
            static INERTIA_LOSS = Math.max(0.005, FrequencyScanner.INERTIA_THRESHOLD / 10); // Чем ниже порог, тем меньше потеря

            constructor(sampler) {
                this.sampler = sampler;
                this.loopFilter = new KalmanFilter(0.0, 0.0, 0.001, 0.01);
                this.vcoFrequency = 0.0; // Начальная частота 0
                this.internalPhase = 0.0;
                this.inertia = 0.0;
                this.currentState = 'SEARCHING';
                this.out_freqHz = 0.0;
                this.out_conf = 0.0;
                this.out_inertia = 0.0;
                this.out_state = 'SEARCHING';
                this.win = new Array(this.constructor.N).fill(0);
                this.block = new Array(this.constructor.N).fill(0);
                this.r = 0;

                for (let n = 0; n < this.constructor.N; ++n) {
                    this.win[n] = 0.5 * (1.0 - Math.cos(2.0 * Math.PI * n / (this.constructor.N - 1)));
                }
            }

            grabBlock() {
                let w = this.sampler.widx;
                let avail = (w - this.r) & this.sampler.constructor.MASK;
                if (avail < this.constructor.N) return false;
                for (let i = 0; i < this.constructor.N; ++i) {
                    this.block[i] = this.sampler.rb[(this.r + i) & this.sampler.constructor.MASK] * this.win[i];
                }
                this.r = (this.r + this.constructor.N) & this.sampler.constructor.MASK;
                return true;
            }

            evalAt(f) {
                let g = new Goertzel();
                g.init(this.constructor.N, this.constructor.FS, f);
                for (let v of this.block) g.push(v);
                let res = g.result();
                if (!isFinite(res.mag)) res.mag = 0;
                return res;
            }

            wrapAngle(angle) {
                return Math.atan2(Math.sin(angle), Math.cos(angle));
            }

            processOnce() {
                if (!this.grabBlock()) return;

                let bestF = this.vcoFrequency;
                let maxMag = -1.0;
                let bestRes = null;
                let sumMag = 0;
                let count = 0;
                for (let f = this.constructor.F_MIN; f <= this.constructor.F_MAX; f += this.constructor.F_STEP) {
                    let resF = this.evalAt(f);
                    sumMag += resF.mag;
                    count++;
                    if (resF.mag > maxMag) {
                        maxMag = resF.mag;
                        bestF = f;
                        bestRes = resF;
                    }
                }
                let avgMag = sumMag / count;
                this.vcoFrequency = bestF;
                let res = bestRes || this.evalAt(this.vcoFrequency);
                let measuredPhase = res.ph;
                let currentMag = res.mag;

                // Локальная энергия ±2 шага
                let localEnergy = this.constructor.EPSILON;
                for (let df = -2; df <= 2; ++df) {
                    localEnergy += this.evalAt(this.vcoFrequency + df * this.constructor.F_STEP).mag;
                }
                let conf = Math.max(0.0, Math.min(1.0, currentMag / localEnergy));
                let peakness = (avgMag > 0) ? currentMag / avgMag : 0;

                // Автоматизированный порог и коэффициенты
                if (conf > this.constructor.INERTIA_THRESHOLD || peakness > 1.2) {
                    this.inertia += this.constructor.INERTIA_GAIN * (1.0 - this.inertia);
                } else {
                    this.inertia -= this.constructor.INERTIA_LOSS * this.inertia;
                }
                this.inertia = Math.max(0.0, Math.min(1.0, this.inertia));

                // Переключение состояния
                if (this.inertia < 0.1 && this.currentState === 'TRACKING') {
                    this.currentState = 'SEARCHING';
                } else if (this.inertia > 0.5 && this.currentState === 'SEARCHING') {
                    this.currentState = 'TRACKING';
                    this.loopFilter.reset(0.0, 0.0);
                }

                // Калман-фильтр и синхронизация
                let phaseError = this.wrapAngle(measuredPhase - this.internalPhase);
                this.loopFilter.predict(this.constructor.DT_WIN);
                let measurementNoise = 0.05 + (1.0 - conf) * 5.0 + this.inertia * 20.0;
                this.loopFilter.update(phaseError, measurementNoise);
                let controlOutput = this.loopFilter.getValue();
                this.vcoFrequency += this.constructor.K_VCO * controlOutput;
                this.vcoFrequency = Math.max(this.constructor.F_MIN, Math.min(this.constructor.F_MAX, this.vcoFrequency));
                this.internalPhase = this.wrapAngle(this.internalPhase + 2.0 * Math.PI * this.vcoFrequency * this.constructor.DT_WIN);

                this.out_freqHz = this.vcoFrequency;
                this.out_conf = conf;
                this.out_inertia = this.inertia;
                this.out_state = this.currentState;
            }
        }

        // Инициализация алгоритма
        const sampler = new MathJitterSampler();
        const scanner = new FrequencyScanner(sampler);
        let running = true;

        // Функция обновления шкал
        let firstDraw = true;
        function updateBars() {
            if (!running) return;
            for (let i = 0; i < 20; ++i) sampler.sample();
            scanner.processOnce();

            // Обновление значений и ширины шкал
            const freqMax = FrequencyScanner.F_MAX;
            document.getElementById('freqValue').innerText = scanner.out_freqHz.toFixed(2);
            document.getElementById('freqBar').style.width = Math.min(100, 100 * scanner.out_freqHz / freqMax) + "%";

            document.getElementById('inertiaValue').innerText = (scanner.out_inertia * 100).toFixed(0);
            document.getElementById('inertiaBar').style.width = Math.min(100, scanner.out_inertia * 100) + "%";

            document.getElementById('confValue').innerText = scanner.out_conf.toFixed(2);
            document.getElementById('confBar').style.width = Math.min(100, scanner.out_conf * 100) + "%";

            document.getElementById('info').innerText =
                `State: ${scanner.out_state} | Freq: ${scanner.out_freqHz.toFixed(3)} Hz | Inertia: ${(scanner.out_inertia * 100).toFixed(0)}% | Conf: ${scanner.out_conf.toFixed(2)}`;

            if (firstDraw) {
                document.getElementById('loading').style.display = 'none';
                firstDraw = false;
            }

            setTimeout(updateBars, 100);
        }

        window.Telegram.WebApp.ready();
        updateBars();
        window.Telegram.WebApp.onEvent('viewportChanged', () => {
            if (!window.Telegram.WebApp.isExpanded) {
                running = false;
            }
        });
    </script>
    <script id="worker-script" type="javascript/worker">
        setInterval(() => {
            let x = 1.0001;
            for (let i = 0; i < 100000; ++i) {
                x *= 1.00000001;
                x /= 1.000000009;
            }
        }, 10);
    </script>
    (function(){
        const blob = new Blob([document.getElementById('worker-script').textContent], { type: "application/javascript" });
        const worker = new Worker(URL.createObjectURL(blob));
    })();
</body>
</html>