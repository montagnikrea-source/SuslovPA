<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Frequency Scanner (CPU-only, Auto-Scale)</title>
  <style>
    :root {
      --main-bg:#f3f5f7; --panel-bg:#fff; --muted:#556; --bar:#e8ebef;
    }
    html,body{margin:0;background:var(--main-bg);font:14px/1.4 system-ui,Segoe UI,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:24px;background:var(--panel-bg);border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07)}
    h1{margin:0 0 10px}
    #loading{margin:6px 0 12px}
    #loading .bg{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    #loading .fill{height:100%;width:0%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);transition:width .25s}
    #statusText{color:var(--muted);margin-top:6px}
    .row{margin-top:12px}
    .lbl{margin:10px 0 6px}
    .bar{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    .f{height:100%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);width:0%}
    .i{height:100%;background:linear-gradient(90deg,#18b56c 60%,#9ef0c5);width:0%}
    .c{height:100%;background:linear-gradient(90deg,#ff9800 60%,#ffd699);width:0%}
    #info{margin-top:14px;font-family:ui-monospace,Consolas,Menlo,monospace;white-space:pre-wrap;color:#222}
    #about{margin-top:18px;color:#222}
    ul{margin:6px 0 0 18px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Frequency Scanner (CPU-only)</h1>

  <div id="loading">
    <div class="bg"><div id="loadingBar" class="fill"></div></div>
    <div id="statusText">Ожидание накопления данных…</div>
  </div>

  <div class="row">
    <div class="lbl">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
    <div class="bar"><div id="freqBar" class="f"></div></div>

    <div class="lbl">Стабильность (%): <span id="inertiaValue">0</span></div>
    <div class="bar"><div id="inertiaBar" class="i"></div></div>

    <div class="lbl">Уверенность: <span id="confValue">0</span></div>
    <div class="bar"><div id="confBar" class="c"></div></div>
  </div>

  <div id="info"></div>

  <div id="about">
    <h2>Как это работает</h2>
    <ul>
      <li>Только CPU. Измеряем время вычисления короткого детерминированного ядра.</li>
      <li>Самомасштабирование: подбор итераций под целевую длительность сэмпла, авто-размер окна, авто-полоса поиска, авто-шаг сканирования, адаптивный шум измерения в Калман-фильтре.</li>
      <li>Если «тихо», создайте лёгкую фоновую активность (видео во вкладке и т. п.).</li>
    </ul>
  </div>
</div>

<script>
/* ====================== Адаптивный CPU-сэмплер ====================== */
class CpuJitterSampler {
  static RB_SIZE = 16384;
  static MASK    = CpuJitterSampler.RB_SIZE - 1;

  constructor() {
    this.rb = new Float64Array(CpuJitterSampler.RB_SIZE);
    this.ts = new Float64Array(CpuJitterSampler.RB_SIZE);
    this.widx = 0;

    // целевое время одного измерения, мс (само корректируется)
    this.target_ms = 2.0;

    // реальное ядро нагрузки — «инвариантно» на всех машинах
    this.iters = 800;               // самоадаптируется
    this.iters_min = 100;
    this.iters_max = 100000;

    // EMA и RMS джиттера
    this.alpha = 0.01;
    this.ema   = 0;                 // сглаженная длительность сэмпла
    this.rms   = 0;                 // сглаженный RMS джиттера (кв. среднего)

    // служебные
    this.dynamic_n = 64;            // размер окна анализа (авто)
    this.actual_fs = 500;           // реальная частота сэмплирования (авто)

    this.sample_count = 0;
    this.last_widx = 0;
    this.last_check = performance.now();
    this.stall_count = 0;
  }

  _kernel(iterations) {
    let x = 1.0001;
    for (let i = 0; i < iterations; ++i) {
      // минимально чувствительные FLOPs
      x *= 1.00000001;
      x /= 1.000000009;
    }
  }

  sample() {
    const t0 = performance.now();
    this._kernel(this.iters);
    const dt = performance.now() - t0;

    // EMA по длительности сэмпла
    if (this.ema === 0) this.ema = dt;
    this.ema = (1 - this.alpha) * this.ema + this.alpha * dt;

    // джиттер = отклонение от EMA
    const jitter = dt - this.ema;

    // запись в кольцевой буфер
    const idx = (this.widx++) & CpuJitterSampler.MASK;
    this.rb[idx] = jitter;
    this.ts[idx] = t0;
    this.sample_count++;

    // сглаженный RMS
    this.rms = (1 - this.alpha) * this.rms + this.alpha * (jitter * jitter);

    // авто-скейл: держим длительность около target_ms -> меняем iters
    if ((this.sample_count & 0x7F) === 0) { // раз в ~128 сэмплов
      const ratio = this.ema / Math.max(0.2, this.target_ms); // защита от деления на ~0
      // мягкая коррекция с ограничением шага
      const k = Math.max(0.5, Math.min(2.0, 1.0 / ratio));
      this.iters = Math.round(this.iters * k);
      this.iters = Math.max(this.iters_min, Math.min(this.iters_max, this.iters));

      // реальная частота дискретизации и авто-окно
      this.actual_fs = 1000.0 / Math.max(0.2, this.ema);
      // окно ≈ 1/4 секунды наблюдений, границы [32..512]
      this.dynamic_n = Math.max(32, Math.min(512, Math.ceil(0.25 * this.actual_fs)));
    }
  }

  checkStall() {
    const now = performance.now();
    if (now - this.last_check > 1000 && this.widx === this.last_widx) {
      this.stall_count++;
      if (this.stall_count > 2) {
        // агрессивное снижение нагрузки при застревании
        this.iters = Math.max(this.iters_min, (this.iters / 2) | 0);
        this.target_ms = Math.min(6.0, this.target_ms * 1.2);
        this.stall_count = 0;
      }
      return true;
    }
    this.last_check = now;
    this.last_widx = this.widx;
    this.stall_count = 0;
    return false;
  }
}

/* ============================= Goertzel ============================= */
class Goertzel {
  init(n, fs, f) {
    this.N = n;
    const k = Math.floor(0.5 + n * f / fs);
    const w = 2.0 * Math.PI * k / n;
    this.cw = Math.cos(w);
    this.sw = Math.sin(w);
    this.s1 = 0; this.s2 = 0;
  }
  push(x) { const s = x + 2.0*this.cw*this.s1 - this.s2; this.s2 = this.s1; this.s1 = s; }
  result() {
    const re = this.s1 - this.s2*this.cw, im = this.s2*this.sw;
    const mag = Math.hypot(re, im) / (this.N > 1 ? (this.N/2) : 1);
    const ph  = Math.atan2(im, re);
    return { mag, ph };
  }
}

/* ============================ 1D Калман ============================ */
class Kalman {
  constructor(x0, v0, qpos, qvel){ this.qp=qpos; this.qv=qvel; this.reset(x0,v0); }
  reset(x,v){ this.x=x; this.v=v; this.p00=1; this.p01=0; this.p10=0; this.p11=1; }
  predict(dt){
    this.x += this.v*dt;
    this.p00 += dt*(this.p10+this.p01) + dt*dt*this.p11;
    this.p01 += dt*this.p11; this.p10 += dt*this.p11;
    this.p00 += this.qp; this.p11 += this.qv;
  }
  update(z,r){
    const y = z - this.x, s = this.p00 + r; if (Math.abs(s) < 1e-9) return;
    const k0 = this.p00/s, k1 = this.p10/s;
    this.x += k0*y; this.v += k1*y;
    const p00=this.p00, p01=this.p01;
    this.p00 -= k0*p00; this.p01 -= k0*p01; this.p10 -= k1*p00; this.p11 -= k1*p01;
  }
}

/* ========================= Частотный сканер ======================== */
class FrequencyScanner {
  constructor(sampler){
    this.s = sampler;
    this.kf = new Kalman(0,0,0.001,0.01);

    this.vco = 0;            // внутренняя целевая частота
    this.phi = 0;            // внутренняя фаза
    this.inertia = 0;        // «устойчивость захвата»
    this.state = 'SEARCHING';

    this.r = 0;              // «читательский» индекс окна
    this.N = this.s.dynamic_n;
    this.win = new Float64Array(this.N);
    this.block = new Float64Array(this.N);
    this.tstamps = new Float64Array(this.N);
    this._rebuildWin = true;

    // авто-параметры
    this.fmax = 50;          // авто по fs
    this.fstep = 0.1;        // авто по fmax/points
    this.maxPoints = 220;
    this.kp = 0.3;           // авто по fs
    this.kv = 0.03;          // авто по fs

    // выходы
    this.out_f = 0; this.out_conf = 0; this.out_inertia = 0; this.out_state = 'SEARCHING';
    this.out_peak = 0; this.dt = 0; this.fs = 0;
  }

  _wrap(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }

  _ensureWin() {
    if (!this._rebuildWin) return;
    const N = this.N;
    for (let n=0;n<N;n++) this.win[n] = 0.5*(1 - Math.cos(2*Math.PI*n/(N-1)));
    this._rebuildWin = false;
  }

  _refreshBuffersIfNeeded() {
    if (this.N !== this.s.dynamic_n) {
      this.N = this.s.dynamic_n;
      this.win = new Float64Array(this.N);
      this.block = new Float64Array(this.N);
      this.tstamps = new Float64Array(this.N);
      this._rebuildWin = true;
    }
    this._ensureWin();
  }

  _grab() {
    this._refreshBuffersIfNeeded();

    const avail = (this.s.widx - this.r) & CpuJitterSampler.MASK;
    if (avail < this.N) return false;

    for (let i=0;i<this.N;i++){
      const idx = (this.r + i) & CpuJitterSampler.MASK;
      this.block[i] = this.s.rb[idx] * this.win[i];
      this.tstamps[i] = this.s.ts[idx];
    }
    const total = this.tstamps[this.N-1] - this.tstamps[0]; // мс
    this.dt = (total/1000) / Math.max(1,(this.N-1));
    this.fs = 1.0 / Math.max(1e-6, this.dt);
    this.r = (this.r + this.N) & CpuJitterSampler.MASK;
    return true;
  }

  _evalAt(f){
    const g = new Goertzel(); g.init(this.N, this.fs, Math.max(0, Math.min(this.fmax, f)));
    for (let i=0;i<this.N;i++) g.push(this.block[i]);
    return g.result();
  }

  _updateAutoParams(){
    this.fmax  = Math.min(100, this.s.actual_fs / 2);
    this.fstep = Math.max(0.02, this.fmax / 220);
    const scale = this.s.actual_fs / 100;
    this.kp = 0.30 * scale;
    this.kv = 0.03 * scale;
  }

  processOnce(){
    if (!this._grab()) return;

    this._updateAutoParams();

    // узкая полоса при захвате, широкая при поиске (самомасштаб)
    let fmin = 0, fmax = this.fmax, fstep = this.fstep;
    if (this.state === 'TRACKING') {
      const span = 0.10 * this.fmax;
      fmin = Math.max(0, this.vco - span);
      fmax = Math.min(this.fmax, this.vco + span);
      fstep = Math.max(this.fstep/5, 0.01);
    }
    let steps = Math.floor((fmax - fmin)/fstep);
    if (steps > this.maxPoints) fstep = (fmax - fmin) / this.maxPoints;

    // поиск максимума и оценка контекста
    let bestF = this.vco, bestMag = -1, best = null, sumMag = 0, cnt = 0;
    for (let f=fmin; f<=fmax+1e-9; f+=fstep) {
      const r = this._evalAt(f);
      sumMag += r.mag; cnt++;
      if (r.mag > bestMag){ bestMag = r.mag; bestF = f; best = r; }
    }
    const avgMag = cnt ? (sumMag/cnt) : 0;
    const cur = best || this._evalAt(this.vco);

    // локальная энергия вокруг текущей частоты для уверенности
    let local = Number.EPSILON;
    for (let df=-2; df<=2; ++df) local += this._evalAt(this.vco + df*fstep).mag;

    const conf = Math.max(0, Math.min(1, (local>0 ? cur.mag/local : 0)));
    const peak = (avgMag>0) ? (cur.mag/avgMag) : 0;

    // инерция (самомасштабируемая скорость накапливания)
    if (conf > 0.06 || peak > 1.0) this.inertia += 0.5*(1 - this.inertia);
    else this.inertia *= 0.98;
    this.inertia = Math.max(0, Math.min(1, this.inertia));

    if (this.inertia < 0.05 && this.state === 'TRACKING') this.state = 'SEARCHING';
    else if (this.inertia > 0.30 && this.state === 'SEARCHING'){ this.state = 'TRACKING'; this.kf.reset(0,0); }

    if (this.state !== 'TRACKING') this.vco = bestF;

    // фазовая ошибка и Калман с авто-шумом измерения (чем хуже SNR, тем шум выше)
    const phaseErr = this._wrap(cur.ph - this.phi);
    this.kf.predict(this.dt);
    const rMeas = 0.05 + (1 - conf)*5.0 + (1 - this.inertia)*20.0;
    this.kf.update(phaseErr, rMeas);
    const u = this.kf.x;

    // авто-усиление по fs (настроено в _updateAutoParams)
    this.vco += this.kp*u + this.kv*this.kf.v;
    this.vco = Math.max(0, Math.min(this.fmax, this.vco));
    this.phi = this._wrap(this.phi + 2*Math.PI*this.vco*this.dt);

    // выходы
    this.out_f = this.vco;
    this.out_conf = conf;
    this.out_inertia = this.inertia;
    this.out_state = this.state;
    this.out_peak = peak;
  }
}

/* =============================== UI =============================== */
document.addEventListener('DOMContentLoaded', () => {
  const s = new CpuJitterSampler();
  const scan = new FrequencyScanner(s);

  // Возможность лёгкой «фоновой нагрузки» через Web Worker (CPU тоже)
  let worker = null;
  try {
    const code = `
      let it=1000, tick=10;
      onmessage = (e)=>{ it=e.data.it||it; tick=e.data.dt||tick; };
      function step(){ let x=1.0001; for (let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } setTimeout(()=>postMessage(1), tick); }
      setInterval(step, 10);
    `;
    worker = new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
    worker.onmessage = ()=>{};
  } catch(_) { /* no worker – не критично */ }

  const $ = id => document.getElementById(id);
  const setText = (id, v)=>{ const el=$(id); if (el) el.textContent = v; };
  const setW = (id, p)=>{ const el=$(id); if (el) el.style.width = Math.max(0,Math.min(100,p)).toFixed(0)+'%'; };
  const nowStr = ()=> new Date().toLocaleTimeString('ru-RU');

  function emulateLoad(it){ let x=1.0001; for (let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } }

  function loop(){
    try{
      // наполняем окно
      const need = (((s.widx - scan.r) & CpuJitterSampler.MASK) < s.dynamic_n);
      if (need){
        for (let i=0;i<300;i++) s.sample();      // быстро добираем буфер
        if (!worker) emulateLoad(600);           // фоновая нагрузка (если нет воркера)
        const fill = ((s.widx - scan.r) & CpuJitterSampler.MASK) / Math.max(1, s.dynamic_n) * 100;
        setW('loadingBar', fill);
        setText('statusText', `Ожидание накопления данных… (${fill.toFixed(0)}%)`);
        if (s.checkStall()) setText('statusText','Застревание сэмплирования! Уменьшаю нагрузку…');
        return setTimeout(loop, 60);
      }

      // анализ
      scan.processOnce();

      // адаптивная фоновая нагрузка (по «выразительности» пика)
      const peak = scan.out_peak || 0;
      if (worker) {
        const cur = 600 + Math.max(0, Math.min(14000, Math.round( (1.0 - Math.min(1,peak/1.2)) * 12000 )));
        worker.postMessage({it:cur, dt:10});
      }

      // статусы
      if (s.actual_fs < 50) setText('statusText','Частота сэмплирования слишком низкая (<50 Гц). Откройте другие приложения для увеличения активности.');
      else if (scan.out_conf < 0.02 && Math.sqrt(s.rms) < 0.01) setText('statusText','Недостаточно фоновой активности, откройте другие вкладки/приложения.');
      else setText('statusText','Анализируется… (CPU)');

      // UI
      const fmax = Math.max(1, scan.fmax);
      setText('freqValue', scan.out_f.toFixed(2));
      setW('freqBar', 100*scan.out_f/fmax);

      setText('inertiaValue', (scan.out_inertia*100).toFixed(0));
      setW('inertiaBar', scan.out_inertia*100);

      setText('confValue', scan.out_conf.toFixed(2));
      setW('confBar', scan.out_conf*100);

      setText('info',
        `Состояние: ${scan.out_state} | Частота: ${scan.out_f.toFixed(3)} Гц | `+
        `Стабильность: ${(scan.out_inertia*100).toFixed(0)}% | Уверенность: ${scan.out_conf.toFixed(2)} | `+
        `fs: ${s.actual_fs.toFixed(1)} Гц | N: ${s.dynamic_n} | `+
        `Avg: ${s.ema.toFixed(3)} ms | RMS: ${Math.sqrt(s.rms).toFixed(4)} ms | `+
        `iters: ${s.iters} | target: ${s.target_ms.toFixed(1)} ms | Время: ${nowStr()}`
      );

      setTimeout(loop, 180);
    } catch(e){
      setText('info', `Критическая ошибка: ${e.message}. Обновите страницу.`);
      console.error(e);
      setTimeout(loop, 800);
    }
  }
  loop();
});
</script>
</body>
</html>
