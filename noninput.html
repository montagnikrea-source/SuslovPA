<div id="loading">
  <div style="width:100%;background:#eee;border-radius:8px;height:18px;margin-top:8px;">
    <div id="loadingBar" style="height:100%;width:0%;background:linear-gradient(90deg,#007bff 60%,#66bfff);border-radius:8px;transition:width 0.3s;"></div>
  </div>
  <div id="statusText" style="margin-top:8px;color:#555;">Ожидание накопления данных...</div>
</div>

<div class="bar-container">
  <div class="bar-label">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill freq" id="freqBar" style="width:0%"></div></div>

  <div class="bar-label">Стабильность (%): <span id="inertiaValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill inertia" id="inertiaBar" style="width:0%"></div></div>

  <div class="bar-label">Уверенность: <span id="confValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill conf" id="confBar" style="width:0%"></div></div>
</div>

<hr>

<h1 id="gpuTitle">GPU Frequency Scanner Web App</h1>
<div id="descGpu">
  Веб-приложение для анализа вариаций времени выполнения вычислений на GPU.<br />
  Шкалы обновляются в реальном времени.
</div>

<div id="gpuContainer" class="bar-container" style="display:none">
  <div class="bar-label">Частота флуктуаций (Гц): <span id="gpuFreqValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill freq" id="gpuFreqBar" style="width:0%"></div></div>

  <div class="bar-label">Стабильность (%): <span id="gpuInertiaValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill inertia" id="gpuInertiaBar" style="width:0%"></div></div>

  <div class="bar-label">Уверенность: <span id="gpuConfValue">0</span></div>
  <div class="bar-bg"><div class="bar-fill conf" id="gpuConfBar" style="width:0%"></div></div>
</div>

<div id="info"></div>

<div id="about">
  <h2>Как работает приложение?</h2>
  <p>
    <b>Frequency Scanner Web App</b> — инструмент для анализа и стабилизации
    вариаций времени выполнения (jitter). Измеряется время выполнения
    детерминированного набора операций, далее окно данных обрабатывается
    методом Гёрцеля и фильтром Калмана; отображаются частота флуктуаций,
    «стабильность» петли слежения и уверенность в выделенной частоте.
  </p>

  <h3>Как пользоваться?</h3>
  <ul>
    <li><b>Старт:</b> дождитесь завершения накопления окна (прогресс-бар).</li>
    <li><b>Мониторинг:</b> полосы и телеметрия обновляются в реальном времени.</li>
    <li><b>Если слишком тихо:</b> создайте умеренную фоновую нагрузку (другая вкладка/видео/приложение).</li>
  </ul>
  <p>Приложение теперь поддерживает одновременный анализ на CPU и GPU (если WebGPU доступен с поддержкой timestamp-query).</p>
</div>  <script>
    /* ========= ThermalController (простейший адаптер «фоновой нагрузки») ========= */
    class ThermalController {
      constructor(worker) {
        this.worker = worker;
        this.workerIters = 1000;
        this.maxIters = 20000;
      }
      update(peakness) {
        if (peakness > 1.2) {
          this.workerIters = Math.max(500, this.workerIters * 0.8);
        } else if (peakness < 0.8) {
          this.workerIters = Math.min(this.maxIters, this.workerIters * 1.2);
        }
        if (this.worker) {
          try { this.worker.postMessage({ iters: Math.round(this.workerIters), tickMs: 10 }); }
          catch(e) { console.warn("Не удалось отправить сообщение воркеру:", e.message); }
        }
      }
    }

    function createWorker() {
      if (typeof Worker === 'undefined') return null;
      try {
        const workerCode = `
          let iters = 1000, tickMs = 10;
          self.onmessage = (e) => { iters = e.data.iters||iters; tickMs = e.data.tickMs||tickMs; };
          function tick(){
            let x = 1.0001;
            for (let i=0; i<iters; ++i){ x *= 1.00000001; x /= 1.000000009; }
            setTimeout(()=>postMessage({done:true}), tickMs);
          }
          setInterval(tick, tickMs);
        `;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
      } catch (e) {
        console.warn("Web Worker не поддерживается/заблокирован:", e.message);
        return null;
      }
    }

    /* ====================== Сэмплер времени выполнения ======================= */
    class MathJitterSampler {
      static RB_SIZE = 16384;
      static MASK = MathJitterSampler.RB_SIZE - 1;

      constructor() {
        this.rb = new Float64Array(this.constructor.RB_SIZE);
        this.timestamps = new Float64Array(this.constructor.RB_SIZE);
        this.widx = 0;

        this.ema_delta = 0;
        this.alpha = 0.01;

        this.fixed_iterations = 500;
        this.target_sample_time = 2.0;

        this.sample_count = 0;
        this.actual_fs = 500.0;

        this.last_widx = 0;
        this.last_check_time = performance.now();

        this.dynamic_n = 32;
        this.slow_count = 0;
        this.stall_count = 0;

        this.jitter_rms = 0;
      }

      sample() {
        const t0 = performance.now();
        let x = 1.0001;
        for (let i = 0; i < this.fixed_iterations; ++i) { x *= 1.00000001; x /= 1.000000009; }
        const delta = performance.now() - t0;

        if (this.ema_delta === 0) this.ema_delta = delta;
        this.ema_delta = (1 - this.alpha) * this.ema_delta + this.alpha * delta;

        const jitter = delta - this.ema_delta;

        const idx = (this.widx++) & this.constructor.MASK;
        this.rb[idx] = jitter;
        this.timestamps[idx] = t0;
        this.sample_count++;

        this.jitter_rms = (1 - this.alpha) * this.jitter_rms + this.alpha * jitter * jitter;

        if (this.sample_count % 200 === 0) { // реже лог
          // авто-адаптация количества операций
          const adjust = this.ema_delta / this.target_sample_time;
          this.fixed_iterations = Math.round(this.fixed_iterations / (adjust || 1));
          this.fixed_iterations = Math.max(100, Math.min(50000, this.fixed_iterations));

          this.actual_fs = 1000.0 / (this.ema_delta || 1);
          this.dynamic_n = Math.max(16, Math.min(512, Math.ceil(0.25 * this.actual_fs)));

          if (this.ema_delta > 10.0) {
            this.slow_count++;
            if (this.slow_count > 5) {
              this.fixed_iterations = Math.max(100, this.fixed_iterations >> 1);
              this.dynamic_n = Math.max(16, this.dynamic_n >> 1);
              this.slow_count = 0;
              console.log("Слишком медленно, уменьшаю нагрузку → iters:", this.fixed_iterations, "N:", this.dynamic_n);
            }
          } else {
            this.slow_count = 0;
          }
        }
      }

      checkStall() {
        const now = performance.now();
        if (now - this.last_check_time > 1000 && this.widx === this.last_widx) {
          this.stall_count++;
          if (this.stall_count > 3) {
            console.warn("Обнаружено застревание сэмплирования — понижаю нагрузку.");
            this.fixed_iterations = Math.max(100, this.fixed_iterations >> 1);
            this.dynamic_n = Math.max(16, this.dynamic_n >> 1);
            this.stall_count = 0;
          }
          return true;
        }
        this.last_check_time = now;
        this.last_widx = this.widx;
        this.stall_count = 0;
        return false;
      }
    }

    class GpuJitterSampler extends MathJitterSampler {
      constructor() {
        super();
        this.device = null;
        this.pipeline = null;
        this.bindGroup = null;
        this.itersBuffer = null;
        this.querySet = null;
        this.resolveBuffer = null;
        this.readBuffer = null;
        this.maxIters = 10000000;
      }

      async initGpu() {
        if (!navigator.gpu) {
          console.warn("WebGPU not supported");
          return;
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return;
        if (!adapter.features.has('timestamp-query')) {
          console.warn("timestamp-query not supported");
          return;
        }
        this.device = await adapter.requestDevice({
          requiredFeatures: ['timestamp-query']
        });
        this.querySet = this.device.createQuerySet({ type: 'timestamp', count: 2 });
        this.resolveBuffer = this.device.createBuffer({ size: 16, usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC });
        this.readBuffer = this.device.createBuffer({ size: 16, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
        const module = this.device.createShaderModule({
          code: `
@group(0) @binding(0) var<uniform> iters: i32;
@compute @workgroup_size(1)
fn main() {
  var x: f32 = 1.0001f;
  for (var i: i32 = 0; i < iters; i = i + 1) {
    x = x * 1.00000001f;
    x = x / 1.000000009f;
  }
}
          `
        });
        this.pipeline = this.device.createComputePipeline({
          layout: 'auto',
          compute: { module, entryPoint: 'main' }
        });
        this.itersBuffer = this.device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.bindGroup = this.device.createBindGroup({
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: this.itersBuffer } }]
        });
      }

      async sample() {
        if (!this.device) {
          return super.sample();
        }
        this.device.queue.writeBuffer(this.itersBuffer, 0, new Int32Array([this.fixed_iterations]));
        const encoder = this.device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.writeTimestamp(this.querySet, 0);
        pass.setPipeline(this.pipeline);
        pass.setBindGroup(0, this.bindGroup);
        pass.dispatchWorkgroups(1);
        pass.writeTimestamp(this.querySet, 1);
        pass.end();
        this.device.queue.submit([encoder.finish()]);
        await this.device.queue.onSubmittedWorkDone();
        const resolveEncoder = this.device.createCommandEncoder();
        resolveEncoder.resolveQuerySet(this.querySet, 0, 2, this.resolveBuffer, 0);
        this.device.queue.submit([resolveEncoder.finish()]);
        const copyEncoder = this.device.createCommandEncoder();
        copyEncoder.copyBufferToBuffer(this.resolveBuffer, 0, this.readBuffer, 0, 16);
        this.device.queue.submit([copyEncoder.finish()]);
        await this.readBuffer.mapAsync(GPUMapMode.READ);
        const times = new BigInt64Array(this.readBuffer.getMappedRange());
        let delta = Number(times[1] - times[0]) / 1000000.0;
        this.readBuffer.unmap();
        if (delta <= 0) {
          console.warn("Invalid GPU delta, falling back to host time");
          delta = performance.now() - performance.now(); // dummy, or implement fallback
        }
        if (this.ema_delta === 0) this.ema_delta = delta;
        this.ema_delta = (1 - this.alpha) * this.ema_delta + this.alpha * delta;
        const jitter = delta - this.ema_delta;
        const idx = (this.widx++) & this.constructor.MASK;
        this.rb[idx] = jitter;
        this.timestamps[idx] = performance.now();
        this.sample_count++;
        this.jitter_rms = (1 - this.alpha) * this.jitter_rms + this.alpha * jitter * jitter;
        if (this.sample_count % 200 === 0) {
          const adjust = this.ema_delta / this.target_sample_time;
          this.fixed_iterations = Math.round(this.fixed_iterations / (adjust || 1));
          this.fixed_iterations = Math.max(100, Math.min(this.maxIters, this.fixed_iterations));
          this.actual_fs = 1000.0 / (this.ema_delta || 1);
          this.dynamic_n = Math.max(16, Math.min(512, Math.ceil(0.25 * this.actual_fs)));
          if (this.ema_delta > 10.0) {
            this.slow_count++;
            if (this.slow_count > 5) {
              this.fixed_iterations = Math.max(100, this.fixed_iterations >> 1);
              this.dynamic_n = Math.max(16, this.dynamic_n >> 1);
              this.slow_count = 0;
              console.log("Слишком медленно (GPU), уменьшаю нагрузку → iters:", this.fixed_iterations, "N:", this.dynamic_n);
            }
          } else {
            this.slow_count = 0;
          }
        }
      }
    }

    /* ============================= Goertzel ============================= */
    class Goertzel {
      init(n, fs, f) {
        this.N = n;
        const k = Math.floor(0.5 + n * f / fs);
        const w = 2.0 * Math.PI * k / n;
        this.cw = Math.cos(w);
        this.sw = Math.sin(w);
        this.s1 = 0; this.s2 = 0;
      }
      push(x) {
        const s = x + 2.0 * this.cw * this.s1 - this.s2;
        this.s2 = this.s1; this.s1 = s;
      }
      result() {
        const re = this.s1 - this.s2 * this.cw;
        const im = this.s2 * this.sw;
        const denom = this.N > 1 ? (this.N / 2.0) : 1.0;
        const mag = Math.sqrt(Math.max(0, re*re + im*im)) / denom;
        const ph = Math.atan2(im, re);
        return { re, im, mag, ph };
      }
    }

    /* ============================ Калман 1D ============================ */
    class KalmanFilter {
      constructor(x0, v0, qpos, qvel){ this.q_pos=qpos; this.q_vel=qvel; this.reset(x0,v0); }
      reset(value, velocity){
        this.x_hat=value; this.x_vel=velocity;
        this.p_00=1; this.p_01=0; this.p_10=0; this.p_11=1;
      }
      predict(dt){
        this.x_hat += this.x_vel * dt;
        this.p_00 += dt*(this.p_10 + this.p_01) + dt*dt*this.p_11;
        this.p_01 += dt*this.p_11; this.p_10 += dt*this.p_11;
        this.p_00 += this.q_pos; this.p_11 += this.q_vel;
      }
      update(z, r){
        const y = z - this.x_hat;
        const s = this.p_00 + r;
        if (Math.abs(s) < 1e-9) return;
        const k0 = this.p_00 / s, k1 = this.p_10 / s;
        this.x_hat += k0 * y; this.x_vel += k1 * y;
        const p00=this.p_00, p01=this.p_01;
        this.p_00 -= k0 * p00; this.p_01 -= k0 * p01;
        this.p_10 -= k1 * p00; this.p_11 -= k1 * p01;
      }
      getValue(){ return this.x_hat; }
    }

    /* ========================= Частотный сканер ======================== */
    class FrequencyScanner {
      constructor(sampler){
        this.sampler = sampler;

        this.loopFilter = new KalmanFilter(0,0,0.001,0.01);
        this.vcoFrequency = 0;
        this.internalPhase = 0;
        this.inertia = 0;

        this.currentState = 'SEARCHING';
        this.out_freqHz = 0; this.out_conf = 0; this.out_inertia = 0; this.out_state = 'SEARCHING';

        this.r = 0;
        this.f_max = 50;
        this.f_step = 0.1;
        this.k_vco_p = 0.1; this.k_vco_v = 0.01;
        this.max_points = 200;

        // Буферы (переиспользуем)
        this.Nbuf = sampler.dynamic_n;
        this.block = new Float64Array(this.Nbuf);
        this.block_timestamps = new Float64Array(this.Nbuf);
        this.win = new Float64Array(this.Nbuf);
        this._needWinRebuild = true;
      }

      updateParameters(){
        this.f_max = Math.min(100.0, this.sampler.actual_fs / 2);
        this.f_step = Math.max(0.02, this.f_max / 200);
        const scale = this.sampler.actual_fs / 100;
        this.k_vco_p = 0.3 * scale;
        this.k_vco_v = 0.03 * scale;
      }

      grabBlock(){
        if (this.Nbuf !== this.sampler.dynamic_n){
          this.Nbuf = this.sampler.dynamic_n;
          this.block = new Float64Array(this.Nbuf);
          this.block_timestamps = new Float64Array(this.Nbuf);
          this.win = new Float64Array(this.Nbuf);
          this._needWinRebuild = true;
        }
        if (this._needWinRebuild){
          const N = this.Nbuf;
          for (let n=0; n<N; ++n) this.win[n] = 0.5*(1 - Math.cos(2.0*Math.PI*n/(N-1)));
          this._needWinRebuild = false;
        }

        const w = this.sampler.widx;
        const avail = (w - this.r) & this.sampler.constructor.MASK;
        if (avail < this.Nbuf) return false;

        for (let i=0;i<this.Nbuf;++i){
          const idx = (this.r + i) & this.sampler.constructor.MASK;
          this.block[i] = this.sampler.rb[idx] * this.win[i];
          this.block_timestamps[i] = this.sampler.timestamps[idx];
        }
        const total_time = this.block_timestamps[this.Nbuf-1] - this.block_timestamps[0];
        this.dt_win = (total_time / 1000.0) / Math.max(1, (this.Nbuf - 1));
        this.actual_fs = 1.0 / (this.dt_win || 1e-6);

        this.r = (this.r + this.Nbuf) & this.sampler.constructor.MASK;
        return true;
      }

      evalAt(f){
        const g = new Goertzel();
        g.init(this.Nbuf, this.actual_fs, Math.max(0, Math.min(this.f_max, f)));
        for (let i=0;i<this.Nbuf;++i) g.push(this.block[i]);
        const res = g.result();
        if (!isFinite(res.mag)) res.mag = 0;
        return res;
      }

      wrapAngle(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }

      processOnce(){
        if (!this.grabBlock()) return;

        this.updateParameters();

        let bestF = this.vcoFrequency, maxMag = -1, bestRes = null, sumMag = 0, count = 0;

        let f_min = 0, f_max = this.f_max, f_step = this.f_step;
        if (this.currentState === 'TRACKING'){
          const span = 0.1 * this.f_max;
          f_min = Math.max(0, this.vcoFrequency - span);
          f_max = Math.min(this.f_max, this.vcoFrequency + span);
          f_step = Math.max(this.f_step/5, 0.01);
        }

        let steps = Math.floor((f_max - f_min) / f_step);
        if (steps > this.max_points) f_step = (f_max - f_min) / this.max_points;

        for (let f=f_min; f<=f_max+1e-9; f+=f_step){
          const resF = this.evalAt(f);
          sumMag += resF.mag; count++;
          if (resF.mag > maxMag){ maxMag = resF.mag; bestF = f; bestRes = resF; }
        }

        const avgMag = count ? (sumMag / count) : 0;
        const res = bestRes || this.evalAt(this.vcoFrequency);
        const measuredPhase = res.ph;
        const currentMag = res.mag;

        let localEnergy = Number.EPSILON;
        for (let df=-2; df<=2; ++df) localEnergy += this.evalAt(this.vcoFrequency + df*f_step).mag;

        const conf = Math.max(0, Math.min(1, (localEnergy>0 ? currentMag/localEnergy : 0)));
        const peakness = (avgMag>0) ? (currentMag/avgMag) : 0;

        this.out_avgMag = avgMag;
        this.out_peakness = peakness;
        this.out_localEnergy = localEnergy;

        if (conf > 0.05 || peakness > 1.0) this.inertia += 0.5*(1 - this.inertia);
        else this.inertia -= 0.02 * this.inertia;
        this.inertia = Math.max(0, Math.min(1, this.inertia));

        if (this.inertia < 0.05 && this.currentState === 'TRACKING') this.currentState = 'SEARCHING';
        else if (this.inertia > 0.3 && this.currentState === 'SEARCHING'){
          this.currentState = 'TRACKING';
          this.loopFilter.reset(0,0);
        }

        if (this.currentState !== 'TRACKING') this.vcoFrequency = bestF;

        const phaseError = this.wrapAngle(measuredPhase - this.internalPhase);
        this.loopFilter.predict(this.dt_win);
        const measurementNoise = 0.05 + (1 - conf)*5.0 + (1 - this.inertia)*20.0;
        this.loopFilter.update(phaseError, measurementNoise);
        const u = this.loopFilter.getValue();

        this.vcoFrequency += this.k_vco_p*u + this.k_vco_v*this.loopFilter.x_vel;
        this.vcoFrequency = Math.max(0, Math.min(this.f_max, this.vcoFrequency));
        this.internalPhase = this.wrapAngle(this.internalPhase + 2*Math.PI*this.vcoFrequency*this.dt_win);

        this.out_freqHz  = this.vcoFrequency;
        this.out_conf    = conf;
        this.out_inertia = this.inertia;
        this.out_state   = this.currentState;

        if (this.sampler.sample_count % 400 === 0){
          console.log(`Scanner${this.sampler instanceof GpuJitterSampler ? ' (GPU)' : ''}: f=${this.out_freqHz.toFixed(3)}Hz, conf=${this.out_conf.toFixed(2)}, inertia=${this.out_inertia.toFixed(2)}, peak=${this.out_peakness.toFixed(2)}, mag=${maxMag.toFixed(3)}`);
        }
      }
    }

    /* =============================== UI loop =============================== */
    document.addEventListener('DOMContentLoaded', async () => {
      const cpuSampler = new MathJitterSampler();
      const gpuSampler = new GpuJitterSampler();
      await gpuSampler.initGpu();
      if (gpuSampler.device) {
        document.getElementById('gpuTitle').style.display = 'block';
        document.getElementById('descGpu').style.display = 'block';
        document.getElementById('gpuContainer').style.display = 'block';
      } else {
        document.getElementById('gpuTitle').innerText = 'GPU не доступен (WebGPU или timestamp-query не поддерживается)';
        document.getElementById('gpuTitle').style.display = 'block';
        document.getElementById('descGpu').style.display = 'none';
        document.getElementById('gpuContainer').style.display = 'none';
      }
      const cpuScanner = new FrequencyScanner(cpuSampler);
      const gpuScanner = new FrequencyScanner(gpuSampler);

      let running = true;
      const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);

      let worker = createWorker();
      const thermal = new ThermalController(worker);
      if (worker){
        worker.onmessage = (e) => { if (e.data && e.data.done) worker.postMessage({ iters: Math.round(thermal.workerIters), tickMs: 10 }); };
        worker.onerror = (e) => { console.warn("Ошибка воркера:", e.message); worker = null; };
        try { worker.postMessage({ iters: Math.round(thermal.workerIters), tickMs: 10 }); } catch(e){ console.warn("Не удалось запустить воркер:", e.message); worker=null; }
      }

      function emulateLoad(iters){
        let x=1.0001;
        for (let i=0;i<iters;++i){ x*=1.00000001; x/=1.000000009; }
      }

      const $ = (id)=>document.getElementById(id);
      const setText = (id, v)=>{ const el=$(id); if (el) el.innerText = v; };
      const setStyle = (id, prop, v)=>{ const el=$(id); if (el && el.style) el.style[prop]=v; };
      const timeStr = ()=> new Date().toLocaleTimeString('ru-RU');

      async function updateBars(){
        if (!running) return;
        try {
          const cpuAvail = (cpuSampler.widx - cpuScanner.r) & MathJitterSampler.MASK;
          let gpuAvail = cpuAvail;
          if (gpuSampler.device) {
            gpuAvail = (gpuSampler.widx - gpuScanner.r) & MathJitterSampler.MASK;
          }
          const need = (cpuAvail < cpuSampler.dynamic_n) || (gpuSampler.device && gpuAvail < gpuSampler.dynamic_n);

          if (need){
            const num = isMobile?100:300;
            const gpuPromises = [];
            for (let i=0; i<num; ++i) {
              if (gpuSampler.device) gpuPromises.push(gpuSampler.sample());
              cpuSampler.sample();
              if (!worker && isMobile) emulateLoad(thermal.workerIters);
            }
            await Promise.all(gpuPromises);

            const minAvail = Math.min(cpuAvail, gpuAvail);
            const minN = Math.min(cpuSampler.dynamic_n, gpuSampler.dynamic_n);
            const progress = Math.min(100, (minAvail / minN) * 100);
            setStyle('loadingBar','width', progress.toFixed(0)+'%');
            setText('statusText', `Ожидание накопления данных... (${progress.toFixed(0)}%)`);

            let stalled = cpuSampler.checkStall();
            if (gpuSampler.device) stalled = stalled || gpuSampler.checkStall();
            if (stalled) setText('statusText', 'Застревание сэмплирования! Уменьшаю нагрузку...');
            setTimeout(()=> updateBars(), isMobile?100:50);
            return;
          }

          cpuScanner.processOnce();
          if (gpuSampler.device) gpuScanner.processOnce();
          if (!worker && isMobile) emulateLoad(thermal.workerIters);

          let fsLow = cpuSampler.actual_fs < 50;
          let lowActivity = cpuScanner.out_freqHz < 0.01 && cpuScanner.out_inertia < 0.01 && cpuScanner.out_conf < 0.01 && Math.sqrt(cpuSampler.jitter_rms) < 0.01;
          if (gpuSampler.device) {
            fsLow = fsLow || gpuSampler.actual_fs < 50;
            lowActivity = lowActivity || (gpuScanner.out_freqHz < 0.01 && gpuScanner.out_inertia < 0.01 && gpuScanner.out_conf < 0.01 && Math.sqrt(gpuSampler.jitter_rms) < 0.01);
          }
          if (fsLow) {
            setText('statusText', 'Частота сэмплирования слишком низкая (<50 Гц). Откройте другие приложения для увеличения нагрузки.');
          } else if (lowActivity) {
            setText('statusText', 'Недостаточно фоновой активности, откройте другие приложения или вкладки!');
          } else {
            setText('statusText', 'Анализируется...');
          }

          let peakness = cpuScanner.out_peakness || 0;
          if (gpuSampler.device) peakness = (peakness + (gpuScanner.out_peakness || 0)) / 2;
          try { thermal.update(peakness); } catch(e){ console.warn('Ошибка ThermalController:', e.message); }

          const freqMax = cpuScanner.f_max || 50;
          setText('freqValue', cpuScanner.out_freqHz.toFixed(2));
          setStyle('freqBar','width', Math.min(100, 100*cpuScanner.out_freqHz/Math.max(1e-6,freqMax)) + '%');

          setText('inertiaValue', (cpuScanner.out_inertia*100).toFixed(0));
          setStyle('inertiaBar','width', Math.min(100, cpuScanner.out_inertia*100) + '%');

          setText('confValue', cpuScanner.out_conf.toFixed(2));
          setStyle('confBar','width', Math.min(100, cpuScanner.out_conf*100) + '%');

          if (gpuSampler.device) {
            const gpuFreqMax = gpuScanner.f_max || 50;
            setText('gpuFreqValue', gpuScanner.out_freqHz.toFixed(2));
            setStyle('gpuFreqBar','width', Math.min(100, 100*gpuScanner.out_freqHz/Math.max(1e-6,gpuFreqMax)) + '%');

            setText('gpuInertiaValue', (gpuScanner.out_inertia*100).toFixed(0));
            setStyle('gpuInertiaBar','width', Math.min(100, gpuScanner.out_inertia*100) + '%');

            setText('gpuConfValue', gpuScanner.out_conf.toFixed(2));
            setStyle('gpuConfBar','width', Math.min(100, gpuScanner.out_conf*100) + '%');
          }

          let infoText = `CPU: Состояние: ${cpuScanner.out_state} | Частота: ${cpuScanner.out_freqHz.toFixed(3)} Гц | ` +
            `Стабильность: ${(cpuScanner.out_inertia*100).toFixed(0)}% | Уверенность: ${cpuScanner.out_conf.toFixed(2)} | ` +
            `Время: ${timeStr()} | Пик: ${(cpuScanner.out_peakness||0).toFixed(2)} | ` +
            `fs: ${cpuSampler.actual_fs.toFixed(1)} Гц | N: ${cpuSampler.dynamic_n} | Avg sample: ${cpuSampler.ema_delta.toFixed(2)}ms | RMS jitter: ${Math.sqrt(cpuSampler.jitter_rms).toFixed(3)}ms`;

          if (gpuSampler.device) {
            infoText += `\nGPU: Состояние: ${gpuScanner.out_state} | Частота: ${gpuScanner.out_freqHz.toFixed(3)} Гц | ` +
              `Стабильность: ${(gpuScanner.out_inertia*100).toFixed(0)}% | Уверенность: ${gpuScanner.out_conf.toFixed(2)} | ` +
              `Пик: ${(gpuScanner.out_peakness||0).toFixed(2)} | ` +
              `fs: ${gpuSampler.actual_fs.toFixed(1)} Гц | N: ${gpuSampler.dynamic_n} | Avg sample: ${gpuSampler.ema_delta.toFixed(2)}ms | RMS jitter: ${Math.sqrt(gpuSampler.jitter_rms).toFixed(3)}ms`;
          }

          infoText += `\nИтерации воркера: ${Math.round(thermal.workerIters)}`;

          setText('info', infoText);

          setTimeout(()=> updateBars(), isMobile?300:200);
        } catch(e){
          setText('info', `Критическая ошибка: ${e.message}. Обновите страницу.`);
          console.error('Ошибка в updateBars:', e);
          setTimeout(()=> updateBars(), 1000);
        }
      }

      updateBars();
    });
  </script></body>
</html>


