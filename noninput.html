<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Frequency Scanner (CPU-only, Moderate Stabilization)</title>
  <style>
    :root { --bg:#f3f5f7; --panel:#fff; --muted:#556; --bar:#e8ebef; }
    html,body{margin:0;background:var(--bg);font:14px/1.45 system-ui,Segoe UI,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:24px;background:var(--panel);border-radius:16px;box-shadow:0 2px 22px rgba(0,0,0,.07)}
    h1{margin:0 0 10px}
    #loading{margin:6px 0 12px}
    #loading .bg{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    #loading .fill{height:100%;width:0%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);transition:width .25s}
    #statusText{color:var(--muted);margin-top:6px}
    .row{margin-top:12px}
    .lbl{margin:10px 0 6px}
    .bar{height:18px;border-radius:8px;background:var(--bar);overflow:hidden}
    .f{height:100%;background:linear-gradient(90deg,#0a7cff 60%,#69b7ff);width:0%}
    .i{height:100%;background:linear-gradient(90deg,#18b56c 60%,#9ef0c5);width:0%}
    .c{height:100%;background:linear-gradient(90deg,#ff9800 60%,#ffd699);width:0%}
    #info{margin-top:14px;font-family:ui-monospace,Consolas,Menlo,monospace;white-space:pre-wrap;color:#222}
    .hint{color:#444;margin-top:8px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Frequency Scanner (CPU-only, Moderate)</h1>

  <div id="loading">
    <div class="bg"><div id="loadingBar" class="fill"></div></div>
    <div id="statusText">Ожидание накопления данных…</div>
  </div>

  <div class="row">
    <div class="lbl">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
    <div class="bar"><div id="freqBar" class="f"></div></div>

    <div class="lbl">Стабильность (%): <span id="inertiaValue">0</span></div>
    <div class="bar"><div id="inertiaBar" class="i"></div></div>

    <div class="lbl">Уверенность: <span id="confValue">0</span></div>
    <div class="bar"><div id="confBar" class="c"></div></div>
  </div>

  <div id="info"></div>
  <div class="hint">Режим «умеренный»: ограничена скорость изменения частоты, усиления снижены, добавлены фильтры и мёртвая зона по фазе.</div>
</div>

<script>
/* ====================== Адаптивный CPU-сэмплер ====================== */
class CpuJitterSampler {
  static RB_SIZE = 16384;
  static MASK    = CpuJitterSampler.RB_SIZE - 1;

  constructor() {
    this.rb = new Float64Array(CpuJitterSampler.RB_SIZE);
    this.ts = new Float64Array(CpuJitterSampler.RB_SIZE);
    this.widx = 0;

    this.target_ms = 2.4;               // чуть длиннее -> ровнее поток
    this.iters = 900;
    this.iters_min = 120;
    this.iters_max = 100000;

    this.alpha = 0.008;                  // более «тяжёлое» сглаживание
    this.ema   = 0;
    this.rms   = 0;

    this.dynamic_n = 64;
    this.actual_fs = 420;

    this.sample_count = 0;
    this.last_widx = 0;
    this.last_check = performance.now();
    this.stall_count = 0;

    // медианный фильтр небольшого окна для мягкой стабилизации dt
    this._medBuf = new Float64Array(9);
    this._mi = 0;
    this._mlen = 0;
  }

  _kernel(iterations) {
    let x = 1.0001;
    for (let i = 0; i < iterations; ++i) { x *= 1.00000001; x /= 1.000000009; }
  }

  _median9(x){
    const n = this._mlen < 9 ? ++this._mlen : 9;
    this._medBuf[this._mi] = x; this._mi = (this._mi + 1) % 9;
    const tmp = Array.from(this._medBuf.slice(0, n)).sort((a,b)=>a-b);
    return tmp[(n>>1)];
  }

  sample() {
    const t0 = performance.now();
    this._kernel(this.iters);
    let dt = performance.now() - t0;
    dt = this._median9(dt);              // лишняя «ступень» сглаживания

    if (this.ema === 0) this.ema = dt;
    this.ema = (1 - this.alpha) * this.ema + this.alpha * dt;

    const jitter = dt - this.ema;

    const idx = (this.widx++) & CpuJitterSampler.MASK;
    this.rb[idx] = jitter;
    this.ts[idx] = t0;
    this.sample_count++;

    this.rms = (1 - this.alpha) * this.rms + this.alpha * (jitter * jitter);

    if ((this.sample_count & 0x7F) === 0) {
      const ratio = this.ema / Math.max(0.3, this.target_ms);
      const k = Math.max(0.7, Math.min(1.4, 1.0 / ratio));   // умеренная подстройка
      this.iters = Math.round(this.iters * k);
      this.iters = Math.max(this.iters_min, Math.min(this.iters_max, this.iters));

      this.actual_fs = 1000.0 / Math.max(0.3, this.ema);
      // окно ≈ 0.35 сек наблюдений, [48..512]
      this.dynamic_n = Math.max(48, Math.min(512, Math.ceil(0.35 * this.actual_fs)));
    }
  }

  checkStall() {
    const now = performance.now();
    if (now - this.last_check > 1000 && this.widx === this.last_widx) {
      this.stall_count++;
      if (this.stall_count > 2) {
        this.iters = Math.max(this.iters_min, (this.iters / 1.8) | 0);
        this.target_ms = Math.min(7.0, this.target_ms * 1.15);
        this.stall_count = 0;
      }
      return true;
    }
    this.last_check = now;
    this.last_widx = this.widx;
    this.stall_count = 0;
    return false;
  }
}

/* ============================= Goertzel ============================= */
class Goertzel {
  init(n, fs, f) {
    this.N = n;
    const k = Math.floor(0.5 + n * f / fs);
    const w = 2.0 * Math.PI * k / n;
    this.cw = Math.cos(w);
    this.sw = Math.sin(w);
    this.s1 = 0; this.s2 = 0;
  }
  push(x){ const s = x + 2.0*this.cw*this.s1 - this.s2; this.s2=this.s1; this.s1=s; }
  result(){
    const re = this.s1 - this.s2*this.cw, im = this.s2*this.sw;
    const mag = Math.hypot(re, im) / (this.N > 1 ? (this.N/2) : 1);
    const ph  = Math.atan2(im, re);
    return { mag, ph };
  }
}

/* ============================ 1D Калман ============================ */
class Kalman {
  constructor(x0, v0, qpos, qvel){ this.qp=qpos; this.qv=qvel; this.reset(x0,v0); }
  reset(x,v){ this.x=x; this.v=v; this.p00=1; this.p01=0; this.p10=0; this.p11=1; }
  predict(dt){
    this.x += this.v*dt;
    this.p00 += dt*(this.p10+this.p01) + dt*dt*this.p11;
    this.p01 += dt*this.p11; this.p10 += dt*this.p11;
    this.p00 += this.qp; this.p11 += this.qv;
  }
  update(z,r){
    const y = z - this.x, s = this.p00 + r; if (Math.abs(s) < 1e-9) return;
    const k0 = this.p00/s, k1 = this.p10/s;
    this.x += k0*y; this.v += k1*y;
    const p00=this.p00, p01=this.p01;
    this.p00 -= k0*p00; this.p01 -= k0*p01; this.p10 -= k1*p00; this.p11 -= k1*p01;
  }
}

/* ========================= Частотный сканер (умеренный) ======================== */
class FrequencyScanner {
  constructor(sampler){
    this.s = sampler;
    this.kf = new Kalman(0,0,0.0008,0.008);    // мягче, чем раньше

    this.vco = 0;
    this.phi = 0;
    this.inertia = 0;
    this.state = 'SEARCHING';

    this.r = 0;
    this.N = this.s.dynamic_n;
    this.win = new Float64Array(this.N);
    this.block = new Float64Array(this.N);
    this.tst = new Float64Array(this.N);
    this._needWin = true;

    // авто-параметры
    this.fmax = 40;
    this.fstep = 0.1;
    this.maxPoints = 200;

    // умеренные усиления + ограничение скорости
    this.kp_base = 0.18;
    this.kv_base = 0.018;
    this.freq_slew_hz_per_s = 25;          // ограничение |df/dt|
    this.lastUpdateMs = performance.now();

    // фазовая «мёртвая зона» (рад)
    this.phase_dead = 0.03;

    // выходы
    this.out_f = 0; this.out_conf = 0; this.out_inertia = 0; this.out_state = 'SEARCHING';
    this.out_peak = 0; this.dt = 0; this.fs = 0;

    // доп. EMA для частоты — «moderate»
    this.f_ema = 0; this.f_alpha = 0.12;
  }

  _wrap(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }

  _ensureWin(){
    if (!this._needWin) return;
    const N = this.N;
    for (let n=0;n<N;n++) this.win[n] = 0.5*(1 - Math.cos(2*Math.PI*n/(N-1)));
    this._needWin = false;
  }

  _refresh(){
    if (this.N !== this.s.dynamic_n){
      this.N = this.s.dynamic_n;
      this.win = new Float64Array(this.N);
      this.block = new Float64Array(this.N);
      this.tst = new Float64Array(this.N);
      this._needWin = true;
    }
    this._ensureWin();
  }

  _grab(){
    this._refresh();
    const avail = (this.s.widx - this.r) & CpuJitterSampler.MASK;
    if (avail < this.N) return false;

    for (let i=0;i<this.N;i++){
      const idx = (this.r + i) & CpuJitterSampler.MASK;
      this.block[i] = this.s.rb[idx] * this.win[i];
      this.tst[i] = this.s.ts[idx];
    }
    const total = this.tst[this.N-1] - this.tst[0];
    this.dt = (total/1000) / Math.max(1,(this.N-1));
    this.fs = 1.0 / Math.max(1e-6, this.dt);
    this.r = (this.r + this.N) & CpuJitterSampler.MASK;
    return true;
  }

  _evalAt(f){
    const g = new Goertzel(); g.init(this.N, this.fs, Math.max(0, Math.min(this.fmax, f)));
    for (let i=0;i<this.N;i++) g.push(this.block[i]);
    return g.result();
  }

  _autoParams(){
    this.fmax  = Math.min(80, this.s.actual_fs / 2);  // уже, чем раньше
    this.fstep = Math.max(0.02, this.fmax / 240);
    const scale = this.s.actual_fs / 120;             // понижаем усиления
    this.kp = this.kp_base * scale;
    this.kv = this.kv_base * scale;
  }

  processOnce(){
    if (!this._grab()) return;
    this._autoParams();

    // узкая полоса при трекинге + мягкий гистерезис
    let fmin = 0, fmax = this.fmax, fstep = this.fstep;
    if (this.state === 'TRACKING') {
      const span = 0.08 * this.fmax;
      fmin = Math.max(0, this.vco - span);
      fmax = Math.min(this.fmax, this.vco + span);
      fstep = Math.max(this.fstep/6, 0.01);
    }
    let steps = Math.floor((fmax - fmin)/fstep);
    if (steps > this.maxPoints) fstep = (fmax - fmin) / this.maxPoints;

    // поиск максимума
    let bestF = this.vco, bestMag = -1, best=null, sumMag=0, cnt=0;
    for (let f=fmin; f<=fmax+1e-9; f+=fstep){
      const r = this._evalAt(f);
      sumMag += r.mag; cnt++;
      if (r.mag > bestMag){ bestMag=r.mag; bestF=f; best=r; }
    }
    const avgMag = cnt ? (sumMag/cnt) : 0;
    const cur = best || this._evalAt(this.vco);

    // уверенность и пикообразность
    let local = Number.EPSILON;
    for (let df=-2; df<=2; ++df) local += this._evalAt(this.vco + df*fstep).mag;
    const conf = Math.max(0, Math.min(1, (local>0 ? cur.mag/local : 0)));
    const peak = (avgMag>0) ? (cur.mag/avgMag) : 0;

    // инерция — медленнее растёт и медленнее падает
    if (conf > 0.07 || peak > 1.05) this.inertia += 0.35*(1 - this.inertia);
    else this.inertia *= 0.985;
    this.inertia = Math.max(0, Math.min(1, this.inertia));

    if (this.inertia < 0.04 && this.state === 'TRACKING') this.state = 'SEARCHING';
    else if (this.inertia > 0.36 && this.state === 'SEARCHING'){ this.state='TRACKING'; this.kf.reset(0,0); }

    // мягкий EMA для частоты-цели даже в поиске → «умеренно»
    if (this.f_ema === 0) this.f_ema = bestF;
    this.f_ema = (1 - this.f_alpha) * this.f_ema + this.f_alpha * bestF;
    if (this.state !== 'TRACKING') this.vco = this.f_ema;

    // фазовая ошибка c dead-zone
    let phaseErr = this._wrap(cur.ph - this.phi);
    if (Math.abs(phaseErr) < this.phase_dead) phaseErr = 0;

    // Калман (умеренный шум)
    this.kf.predict(this.dt);
    const rMeas = 0.06 + (1 - conf)*3.5 + (1 - this.inertia)*12.0;
    this.kf.update(phaseErr, rMeas);
    const u = this.kf.x;

    // ограничение скорости изменения частоты
    const now = performance.now();
    const dtMs = Math.max(1, now - this.lastUpdateMs);
    this.lastUpdateMs = now;
    const maxStep = this.freq_slew_hz_per_s * (dtMs/1000);

    let df = this.kp*u + this.kv*this.kf.v;
    if (!isFinite(df)) df = 0;
    df = Math.max(-maxStep, Math.min(maxStep, df));

    this.vco = Math.max(0, Math.min(this.fmax, this.vco + df));
    this.phi = this._wrap(this.phi + 2*Math.PI*this.vco*this.dt);

    // выходы
    this.out_f = this.vco;
    this.out_conf = conf;
    this.out_inertia = this.inertia;
    this.out_state = this.state;
    this.out_peak = peak;
  }
}

/* =============================== UI =============================== */
document.addEventListener('DOMContentLoaded', () => {
  const s = new CpuJitterSampler();
  const scan = new FrequencyScanner(s);

  // лёгкая фоновая активность в воркере (тоже CPU) — умеренная
  let worker = null;
  try {
    const code = `
      let it=700, tick=12;
      onmessage = (e)=>{ it=e.data.it||it; tick=e.data.dt||tick; };
      function step(){ let x=1.0001; for (let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } setTimeout(()=>postMessage(1), tick); }
      setInterval(step, 12);
    `;
    worker = new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
    worker.onmessage = ()=>{};
  } catch(_) {}

  const $ = id => document.getElementById(id);
  const setText = (id, v)=>{ const el=$(id); if (el) el.textContent = v; };
  const setW = (id, p)=>{ const el=$(id); if (el) el.style.width = Math.max(0,Math.min(100,p)).toFixed(0)+'%'; };
  const nowStr = ()=> new Date().toLocaleTimeString('ru-RU');

  function emulateLoad(it){ let x=1.0001; for (let i=0;i<it;i++){ x*=1.00000001; x/=1.000000009; } }

  function loop(){
    try{
      // наполняем окно
      const need = (((s.widx - scan.r) & CpuJitterSampler.MASK) < s.dynamic_n);
      if (need){
        for (let i=0;i<260;i++) s.sample();
        if (!worker) emulateLoad(500);
        const fill = ((s.widx - scan.r) & CpuJitterSampler.MASK) / Math.max(1, s.dynamic_n) * 100;
        setW('loadingBar', fill);
        setText('statusText', `Ожидание накопления данных… (${fill.toFixed(0)}%)`);
        if (s.checkStall()) setText('statusText','Застревание сэмплирования! Уменьшаю нагрузку…');
        return setTimeout(loop, 70);
      }

      // анализ
      scan.processOnce();

      // аккуратная авто-нагрузка: чем хуже пик, тем чуть больше «подсветка»
      const peak = scan.out_peak || 0;
      if (worker) {
        const cur = 500 + Math.max(0, Math.min(9000, Math.round( (1.0 - Math.min(1, peak/1.15)) * 8000 )));
        worker.postMessage({it:cur, dt:12});
      }

      // статусы
      if (s.actual_fs < 45) setText('statusText','Частота сэмплирования низкая (<45 Гц). Откройте другие приложения для лёгкой активности.');
      else if (scan.out_conf < 0.02 && Math.sqrt(s.rms) < 0.01) setText('statusText','Слишком «тихо», добавьте умеренную фоновую активность.');
      else setText('statusText','Анализируется… (умеренно)');

      // UI
      const fmax = Math.max(1, scan.fmax);
      setText('freqValue', scan.out_f.toFixed(2));
      setW('freqBar', 100*scan.out_f/fmax);

      setText('inertiaValue', (scan.out_inertia*100).toFixed(0));
      setW('inertiaBar', scan.out_inertia*100);

      setText('confValue', scan.out_conf.toFixed(2));
      setW('confBar', scan.out_conf*100);

      setText('info',
        `Состояние: ${scan.out_state} | Частота: ${scan.out_f.toFixed(3)} Гц | `+
        `Стабильность: ${(scan.out_inertia*100).toFixed(0)}% | Уверенность: ${scan.out_conf.toFixed(2)} | `+
        `fs: ${s.actual_fs.toFixed(1)} Гц | N: ${s.dynamic_n} | `+
        `Avg: ${s.ema.toFixed(3)} ms | RMS: ${Math.sqrt(s.rms).toFixed(4)} ms | `+
        `iters: ${s.iters} | target: ${s.target_ms.toFixed(1)} ms | Время: ${nowStr()}`
      );

      setTimeout(loop, 200); // реже обновляем — тоже добавляет «умеренности»
    } catch(e){
      setText('info', `Критическая ошибка: ${e.message}. Обновите страницу.`);
      console.error(e);
      setTimeout(loop, 800);
    }
  }
  loop();
});
</script>
</body>
</html>
