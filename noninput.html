<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frequency Scanner Web App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --main-bg: #f0f0f0;
            --panel-bg: #fff;
            --bar-bg: #eee;
            --bar-radius: 8px;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--main-bg);
        }
        .embed-wrapper {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 16px;
            box-shadow: 0 2px 8px #ccc;
        }
        h1 { margin-bottom: 10px; font-size: 1.5em; }
        #desc { margin-bottom: 20px; color: #555; }
        #loading { color: #888; margin-bottom: 10px; }
        .bar-container { width: 100%; margin: 20px 0; }
        .bar-label { margin-bottom: 5px; font-size: 16px; color: #333; }
        .bar-bg { width: 100%; height: 32px; background: var(--bar-bg); border-radius: var(--bar-radius); overflow: hidden; margin-bottom: 20px; }
        .bar-fill { height: 100%; transition: width 0.3s; }
        #info { margin-top: 20px; font-size: 16px; word-break: break-word; }
        .freq { background: linear-gradient(90deg, #007bff 60%, #66bfff); }
        .inertia { background: linear-gradient(90deg, #28a745 60%, #7be88b); }
        .conf { background: linear-gradient(90deg, #dc3545 60%, #ffb3b3); }
        #about { margin: 40px 0 0 0; padding: 20px; background: var(--panel-bg); border-radius: 12px; box-shadow: 0 2px 8px #ccc; font-size: 16px; color: #333; }
        #about h2 { margin-top: 0; }
        #about ul { padding-left: 20px; }
        @media (max-width: 700px) {
            .embed-wrapper, #about { max-width: 98vw; padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="embed-wrapper">
        <h1>Frequency Scanner Web App</h1>
        <div id="desc">Веб-приложение для анализа вариаций времени выполнения вычислений.<br>Шкалы обновляются в реальном времени.</div>
        <div id="loading">
            <div style="width:100%;background:#eee;border-radius:8px;height:18px;margin-top:8px;">
                <div id="loadingBar" style="height:100%;width:0%;background:linear-gradient(90deg,#007bff 60%,#66bfff);border-radius:8px;transition:width 0.3s;"></div>
            </div>
            <div id="statusText" style="margin-top:8px;color:#555;">Анализируется...</div>
        </div>
        <div class="bar-container">
            <div class="bar-label">Частота флуктуаций (Гц): <span id="freqValue">0</span></div>
            <div class="bar-bg"><div class="bar-fill freq" id="freqBar" style="width:0%"></div></div>
            <div class="bar-label">Стабильность (%): <span id="inertiaValue">0</span></div>
            <div class="bar-bg"><div class="bar-fill inertia" id="inertiaBar" style="width:0%"></div></div>
            <div class="bar-label">Уверенность: <span id="confValue">0</span></div>
            <div class="bar-bg"><div class="bar-fill conf" id="confBar" style="width:0%"></div></div>
        </div>
        <div id="info"></div>
        <div id="about">
            <h2>Как работает программа?</h2>
            <p>
                Это приложение анализирует вариации времени выполнения простых вычислений (jitter) на вашем устройстве.
                Оно измеряет, сколько времени занимает выполнение фиксированного набора операций, и выявляет периодические флуктуации, вызванные фоновыми процессами, нагрузкой процессора или операционной системы.
                Для анализа используется метод Гёрцеля, который определяет частотные характеристики этих вариаций, а фильтр Калмана помогает стабильно отслеживать частоту.
            </p>
            <p>
                <b>Частота флуктуаций</b> показывает, с какой периодичностью происходят изменения во времени выполнения вычислений (в герцах).<br>
                <b>Стабильность</b> отражает, насколько устойчиво обнаружена частота: высокое значение указывает на стабильный сигнал.<br>
                <b>Уверенность</b> показывает, насколько выделяется основная частота по сравнению с другими (0–1).
            </p>
            <h3>Польза и применение</h3>
            <ul>
                <li>Мониторинг производительности процессора и операционной системы в реальном времени.</li>
                <li>Оценка влияния фоновых задач на стабильность вычислений.</li>
                <li>Тестирование виртуальных машин, контейнеров или облачных сред.</li>
                <li>Выявление нестабильности для оптимизации программ, связанных с обработкой данных.</li>
                <li>Стабилизация передачи данных: приложение позволяет выявлять периоды нестабильности, что помогает оптимизировать работу программ, связанных с обработкой и передачей данных, снижая задержки и потери информации.</li>
            </ul>
            <p>
                Программа работает в браузере без доступа к аппаратным датчикам, полагаясь только на измерение времени вычислений.
                Она лучше всего работает при наличии фоновой активности, создающей заметные флуктуации.
            </p>
        </div>
    </div>
    <script>
        // MathJitterSampler
        class MathJitterSampler {
            static RB_SIZE = 16384;
            static MASK = this.RB_SIZE - 1;

            constructor() {
                this.rb = new Array(this.constructor.RB_SIZE).fill(0);
                this.timestamps = new Array(this.constructor.RB_SIZE).fill(0);
                this.widx = 0;
                this.ema_delta = 0;
                this.alpha = 0.0025;
                this.fixed_iterations = 1000; // Начальное значение для быстрого старта
                this.target_sample_time = 2.0; // Целевое время сэмпла (мс)
                this.sample_count = 0;
                this.actual_fs = 500.0; // Начальная частота
                this.last_widx = 0;
                this.last_check_time = performance.now();
                this.dynamic_n = 128; // Начальное N
                this.slow_count = 0; // Счётчик медленных сэмплов
            }

            sample() {
                let startTime = performance.now();
                let x = 1.0001;
                for (let i = 0; i < this.fixed_iterations; ++i) {
                    x *= 1.00000001;
                    x /= 1.000000009;
                }
                let delta = performance.now() - startTime;
                if (this.ema_delta === 0) {
                    this.ema_delta = delta;
                }
                this.ema_delta = (1.0 - this.alpha) * this.ema_delta + this.alpha * delta;
                let jitter = delta - this.ema_delta;
                let idx = this.widx++ & this.constructor.MASK;
                this.rb[idx] = jitter;
                this.timestamps[idx] = startTime;
                this.sample_count++;
                console.log(`Sampled at widx: ${this.widx}, delta: ${delta.toFixed(2)}ms`); // Debug log

                // Агрессивная адаптация первых 50 сэмплов
                if (this.sample_count <= 50) {
                    let adjustment = this.ema_delta / this.target_sample_time;
                    this.fixed_iterations = Math.round(this.fixed_iterations / adjustment);
                }
                // Полная адаптация каждые 10 сэмплов
                if (this.sample_count % 10 === 0) {
                    let adjustment = this.ema_delta / this.target_sample_time;
                    this.fixed_iterations = Math.round(this.fixed_iterations / adjustment);
                    // Мягкое ограничение для разумных значений
                    if (this.fixed_iterations < 100) this.fixed_iterations *= 2;
                    if (this.fixed_iterations > 1e6) this.fixed_iterations /= 2;
                    this.actual_fs = 1000.0 / this.ema_delta;
                    this.dynamic_n = Math.max(64, Math.min(2048, Math.ceil(0.5 * this.actual_fs)));

                    // Проверка медленных сэмплов
                    if (this.ema_delta > 10.0) {
                        this.slow_count++;
                        if (this.slow_count > 10) {
                            this.fixed_iterations = Math.max(100, this.fixed_iterations / 2); // Снижаем нагрузку
                            this.slow_count = 0;
                            console.log("Слишком медленное сэмплирование, уменьшаю итерации до:", this.fixed_iterations);
                        }
                    } else {
                        this.slow_count = 0;
                    }
                    console.log(`Sample time: ${this.ema_delta.toFixed(2)}ms, iters: ${this.fixed_iterations}, fs: ${this.actual_fs.toFixed(1)}Hz, N: ${this.dynamic_n}`);
                }
            }

            checkStall() {
                let now = performance.now();
                if (now - this.last_check_time > 2000 && this.widx === this.last_widx) {
                    return true;
                }
                this.last_check_time = now;
                this.last_widx = this.widx;
                return false;
            }
        }

        // Goertzel
        class Goertzel {
            constructor() {
                this.N = 0;
                this.cw = 0;
                this.sw = 0;
                this.s1 = 0;
                this.s2 = 0;
            }

            init(n, fs, f) {
                this.N = n;
                let k = Math.floor(0.5 + n * f / fs);
                let w = 2.0 * Math.PI * k / n;
                this.cw = Math.cos(w);
                this.sw = Math.sin(w);
                this.s1 = 0;
                this.s2 = 0;
            }

            push(x) {
                let s = x + 2.0 * this.cw * this.s1 - this.s2;
                this.s2 = this.s1;
                this.s1 = s;
            }

            result() {
                let re = this.s1 - this.s2 * this.cw;
                let im = this.s2 * this.sw;
                let denom = this.N > 1 ? this.N / 2.0 : 1.0;
                let m2 = re * re + im * im;
                let mag = Math.sqrt(m2 < 0 ? 0 : m2) / denom;
                let ph = Math.atan2(im, re);
                this.s1 = 0;
                this.s2 = 0;
                return { re, im, mag, ph };
            }
        }

        // KalmanFilter
        class KalmanFilter {
            constructor(initialValue, initialVelocity, processNoisePos, processNoiseVel) {
                this.q_pos = processNoisePos;
                this.q_vel = processNoiseVel;
                this.reset(initialValue, initialVelocity);
            }

            reset(value, velocity) {
                this.x_hat = value;
                this.x_vel = velocity;
                this.p_00 = 1.0;
                this.p_01 = 0.0;
                this.p_10 = 0.0;
                this.p_11 = 1.0;
            }

            predict(dt) {
                this.x_hat += this.x_vel * dt;
                this.p_00 += dt * (this.p_10 + this.p_01) + dt * dt * this.p_11;
                this.p_01 += dt * this.p_11;
                this.p_10 += dt * this.p_11;
                this.p_00 += this.q_pos;
                this.p_11 += this.q_vel;
            }

            update(z_meas, r_meas_noise) {
                let y = z_meas - this.x_hat;
                let s = this.p_00 + r_meas_noise;
                if (Math.abs(s) < 1e-9) return;
                let k_0 = this.p_00 / s;
                let k_1 = this.p_10 / s;
                this.x_hat += k_0 * y;
                this.x_vel += k_1 * y;
                let p_00_temp = this.p_00, p_01_temp = this.p_01;
                this.p_00 -= k_0 * p_00_temp;
                this.p_01 -= k_0 * p_01_temp;
                this.p_10 -= k_1 * p_00_temp;
                this.p_11 -= k_1 * p_01_temp;
            }

            getValue() {
                return this.x_hat;
            }
        }

        // FrequencyScanner
        class FrequencyScanner {
            constructor(sampler) {
                this.sampler = sampler;
                this.loopFilter = new KalmanFilter(0.0, 0.0, 0.001, 0.01);
                this.vcoFrequency = 0.0;
                this.internalPhase = 0.0;
                this.inertia = 0.0;
                this.currentState = 'SEARCHING';
                this.out_freqHz = 0.0;
                this.out_conf = 0.0;
                this.out_inertia = 0.0;
                this.out_state = 'SEARCHING';
                this.win = new Array(sampler.dynamic_n).fill(0);
                this.block = new Array(sampler.dynamic_n).fill(0);
                this.block_timestamps = new Array(sampler.dynamic_n).fill(0);
                this.r = 0;
                this.f_max = 50.0;
                this.f_step = 0.05;
                this.k_vco_p = 0.1;
                this.k_vco_v = 0.01;
                this.max_points = 500; // Ограничение итераций в скане

                for (let n = 0; n < sampler.dynamic_n; ++n) {
                    this.win[n] = 0.5 * (1.0 - Math.cos(2.0 * Math.PI * n / (sampler.dynamic_n - 1)));
                }
            }

            updateParameters() {
                this.f_max = Math.min(100.0, this.sampler.actual_fs / 2); // Nyquist
                this.f_step = Math.max(0.005, this.f_max / 1000);
                this.k_vco_p = 0.2 * (this.sampler.actual_fs / 100); // Увеличено для быстрого ответа
                this.k_vco_v = 0.02 * (this.sampler.actual_fs / 100); // Увеличено
            }

            grabBlock() {
                let w = this.sampler.widx;
                let avail = (w - this.r) & this.sampler.constructor.MASK;
                if (avail < this.sampler.dynamic_n) return false;
                this.block = new Array(this.sampler.dynamic_n).fill(0);
                this.block_timestamps = new Array(this.sampler.dynamic_n).fill(0);
                this.win = new Array(this.sampler.dynamic_n).fill(0);
                for (let n = 0; n < this.sampler.dynamic_n; ++n) {
                    this.win[n] = 0.5 * (1.0 - Math.cos(2.0 * Math.PI * n / (this.sampler.dynamic_n - 1)));
                }
                for (let i = 0; i < this.sampler.dynamic_n; ++i) {
                    let idx = (this.r + i) & this.sampler.constructor.MASK;
                    this.block[i] = this.sampler.rb[idx] * this.win[i];
                    this.block_timestamps[i] = this.sampler.timestamps[idx];
                }
                let total_time = this.block_timestamps[this.sampler.dynamic_n - 1] - this.block_timestamps[0];
                this.dt_win = total_time / 1000.0 / (this.sampler.dynamic_n - 1);
                this.actual_fs = 1.0 / this.dt_win;
                this.r = (this.r + this.sampler.dynamic_n) & this.sampler.constructor.MASK;
                return true;
            }

            evalAt(f) {
                let g = new Goertzel();
                g.init(this.sampler.dynamic_n, this.actual_fs, f);
                for (let v of this.block) g.push(v);
                let res = g.result();
                if (!isFinite(res.mag)) res.mag = 0;
                return res;
            }

            wrapAngle(angle) {
                return Math.atan2(Math.sin(angle), Math.cos(angle));
            }

            processOnce() {
                if (!this.grabBlock()) return;

                this.updateParameters();

                let bestF = this.vcoFrequency;
                let maxMag = -1.0;
                let bestRes = null;
                let sumMag = 0;
                let count = 0;

                let f_min = 0.0;
                let f_max = this.f_max;
                let f_step = this.f_step;

                if (this.currentState === 'TRACKING') {
                    f_min = Math.max(0.0, this.vcoFrequency - 0.2 * this.f_max);
                    f_max = Math.min(this.f_max, this.vcoFrequency + 0.2 * this.f_max);
                    f_step = this.f_step / 5;
                }

                // Ограничение итераций
                let steps = Math.floor((f_max - f_min) / f_step);
                if (steps > this.max_points) {
                    f_step = (f_max - f_min) / this.max_points;
                }

                for (let f = f_min; f <= f_max; f += f_step) {
                    let resF = this.evalAt(f);
                    sumMag += resF.mag;
                    count++;
                    if (resF.mag > maxMag) {
                        maxMag = resF.mag;
                        bestF = f;
                        bestRes = resF;
                    }
                }
                let avgMag = sumMag / count;
                let res = bestRes || this.evalAt(this.vcoFrequency);
                let measuredPhase = res.ph;
                let currentMag = res.mag;

                let localEnergy = Number.EPSILON;
                for (let df = -2; df <= 2; ++df) {
                    localEnergy += this.evalAt(this.vcoFrequency + df * f_step).mag;
                }
                let conf = Math.max(0.0, Math.min(1.0, currentMag / localEnergy));
                let peakness = (avgMag > 0) ? currentMag / avgMag : 0;

                this.out_avgMag = avgMag;
                this.out_peakness = peakness;
                this.out_localEnergy = localEnergy;

                if (conf > 0.1 || peakness > 1.2) {
                    this.inertia += 0.5 * (1.0 - this.inertia);
                } else {
                    this.inertia -= 0.01 * this.inertia;
                }
                this.inertia = Math.max(0.0, Math.min(1.0, this.inertia));

                if (this.inertia < 0.1 && this.currentState === 'TRACKING') {
                    this.currentState = 'SEARCHING';
                } else if (this.inertia > 0.5 && this.currentState === 'SEARCHING') {
                    this.currentState = 'TRACKING';
                    this.loopFilter.reset(0.0, 0.0);
                }

                if (this.currentState === 'TRACKING') {
                    bestF = this.vcoFrequency;
                }

                this.vcoFrequency = bestF;

                let phaseError = this.wrapAngle(measuredPhase - this.internalPhase);
                this.loopFilter.predict(this.dt_win);
                let measurementNoise = 0.05 + (1.0 - conf) * 5.0 + (1.0 - this.inertia) * 20.0;
                this.loopFilter.update(phaseError, measurementNoise);
                let controlOutput = this.loopFilter.getValue();
                this.vcoFrequency += this.k_vco_p * controlOutput + this.k_vco_v * this.loopFilter.x_vel;
                this.vcoFrequency = Math.max(0.0, Math.min(this.f_max, this.vcoFrequency));
                this.internalPhase = this.wrapAngle(this.internalPhase + 2.0 * Math.PI * this.vcoFrequency * this.dt_win);

                this.out_freqHz = this.vcoFrequency;
                this.out_conf = conf;
                this.out_inertia = this.inertia;
                this.out_state = this.currentState;
            }
        }

        // Инициализация алгоритма
        const sampler = new MathJitterSampler();
        const scanner = new FrequencyScanner(sampler);
        let running = true;
        let firstDraw = true;

        let stableCounter = 0;
        let lastFreq = 0;
        const STABLE_THRESHOLD = 0.5;
        const STABLE_COUNT_REQUIRED = 30;

        // Термостабилизация
        class ThermalController {
            constructor(worker) {
                this.worker = worker;
                this.kp = 25.0;
                this.ki = 0.5;
                this.integral = 0.0;
                this.targetPeak = 1.5;
                this.minIter = 1000;
                this.maxIter = 100000;
                this.lastAdjust = Date.now();
                this.adjustIntervalMs = 200;
                this.workerIters = 50000;
            }

            update(measuredPeakness) {
                const now = Date.now();
                if (now - this.lastAdjust < this.adjustIntervalMs) return;
                this.lastAdjust = now;

                let error = this.targetPeak - measuredPeakness;
                this.integral += error * (this.adjustIntervalMs / 1000.0);
                let control = this.kp * error + this.ki * this.integral;

                let deltaIters = Math.round(control * -1000);
                this.workerIters = Math.max(this.minIter, Math.min(this.maxIter, this.workerIters + deltaIters));
                try { this.worker.postMessage({ iters: this.workerIters }); } catch (e) {}
            }
        }

        // Воркер
    </script>
    <script id="worker-script" type="javascript/worker">
        let iters = 50000;
        let tickMs = 10;
        let timer = null;

        function start() {
            if (timer) clearInterval(timer);
            timer = setInterval(() => {
                let x = 1.0001;
                for (let i = 0; i < iters; ++i) {
                    x *= 1.00000001;
                    x /= 1.000000009;
                }
            }, tickMs);
        }

        onmessage = (e) => {
            if (e.data && typeof e.data.iters === 'number') {
                iters = Math.max(1000, e.data.iters|0);
            }
            if (e.data && typeof e.data.tickMs === 'number') {
                tickMs = Math.max(1, e.data.tickMs|0);
            }
            start();
            postMessage({ status: 'running', iters });
        };

        start();
    </script>
    <script>
    (function(){
        const blob = new Blob([document.getElementById('worker-script').textContent], { type: "application/javascript" });
        const worker = new Worker(URL.createObjectURL(blob));
        worker.onmessage = (e) => console.log('Worker status:', e.data);
        worker.onerror = (e) => console.error('Worker error:', e.message);
        const thermal = new ThermalController(worker);
        worker.postMessage({ iters: thermal.workerIters, tickMs: 10 });

        // Исправленный цикл накопления сэмплов — не зависает!
        let running = true;
        let firstDraw = true;
        let stableCounter = 0;
        let lastFreq = 0;
        const STABLE_THRESHOLD = 0.5;
        const STABLE_COUNT_REQUIRED = 30;

        function getSyncedTimeString() {
            return new Date().toLocaleTimeString('ru-RU');
        }

        let statusText = "Загрузка данных...";

        // Helper function to safely update DOM text
        function updateDOM(id, text) {
            const element = document.getElementById(id);
            if (element) element.innerText = text;
        }

        // Helper function to safely update DOM style
        function updateDOMStyle(id, property, value) {
            const element = document.getElementById(id);
            if (element && element.style) {
                element.style[property] = value;
            }
        }

        function updateBars() {
            if (!running) return;

            try {
                // Обновление строки загрузки (без текста "Загрузка данных...")
                let needSamples = ((sampler.widx - scanner.r) & sampler.constructor.MASK) < sampler.dynamic_n;
                if (needSamples) {
                    for (let i = 0; i < 100; ++i) sampler.sample();
                    let progress = ((sampler.widx / sampler.dynamic_n) * 100) % 100;
                    updateDOMStyle('loadingBar', 'width', Math.min(100, progress) + "%");
                    document.getElementById('statusText').innerText = "Ожидание накопления данных...";
                    updateDOM('info', `Загрузка данных... ${progress.toFixed(0)}%`);
                    setTimeout(updateBars, 50);
                    return;
                }

                // После накопления — анализ
                scanner.processOnce();

                // Статус всегда отображается под шкалой
                if (sampler.actual_fs < 50) {
                    document.getElementById('statusText').innerText = "Частота сэмплирования слишком низкая (<50 Гц). Откройте другие приложения для увеличения нагрузки.";
                } else if (scanner.out_freqHz < 0.01 && scanner.out_inertia < 0.01 && scanner.out_conf < 0.01) {
                    document.getElementById('statusText').innerText = "Недостаточно фоновой активности, откройте другие приложения или вкладки!";
                } else {
                    document.getElementById('statusText').innerText = "Анализируется...";
                }

                // Update thermal controller with fallback
                try {
                    thermal.update(scanner.out_peakness || 0);
                } catch (e) {
                    console.warn('Thermal update error:', e);
                    thermal.workerIters = 50000; // Reset to default
                }

                // Stability check
                if (Math.abs(scanner.out_freqHz - lastFreq) < STABLE_THRESHOLD) {
                    stableCounter++;
                } else {
                    stableCounter = 0;
                }
                lastFreq = scanner.out_freqHz;

                const freqMax = scanner.f_max || 50; // Default to 50 if undefined
                updateDOM('freqValue', scanner.out_freqHz.toFixed(2));
                updateDOMStyle('freqBar', 'width', Math.min(100, 100 * scanner.out_freqHz / freqMax) + "%");

                updateDOM('inertiaValue', (scanner.out_inertia * 100).toFixed(0));
                updateDOMStyle('inertiaBar', 'width', Math.min(100, scanner.out_inertia * 100) + "%");

                updateDOM('confValue', scanner.out_conf.toFixed(2));
                updateDOMStyle('confBar', 'width', Math.min(100, scanner.out_conf * 100) + "%");

                updateDOM('info', `${statusText}\nСостояние: ${scanner.out_state} | Частота: ${scanner.out_freqHz.toFixed(3)} Гц | Стабильность: ${(scanner.out_inertia * 100).toFixed(0)}% | Уверенность: ${scanner.out_conf.toFixed(2)} | Время: ${getSyncedTimeString()} | Пик: ${(scanner.out_peakness||0).toFixed(2)} | Итерации воркера: ${thermal.workerIters} | Частота сэмплирования: ${sampler.actual_fs.toFixed(1)} Гц | N: ${sampler.dynamic_n} | Avg sample time: ${sampler.ema_delta.toFixed(2)}ms`);

                if (firstDraw) {
                    updateDOMStyle('loading', 'display', 'block');
                    firstDraw = false;
                }

                setTimeout(updateBars, 200);
            } catch (e) {
                console.error('Critical error in updateBars:', e);
                updateDOM('info', "Критическая ошибка! Пожалуйста, обновите страницу.");
                setTimeout(updateBars, 1000); // Retry after 1 second
            }
        }

        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.onEvent('viewportChanged', () => {
                if (!window.Telegram.WebApp.isExpanded) {
                    running = false;
                }
            });
        } else {
            console.warn("Running outside Telegram environment, some features may not work.");
            running = true; // Ensure it runs in non-Telegram context
        }
        updateBars();
    })();
    </script>
</body>
</html>